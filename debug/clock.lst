                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ANSI-C Compiler
                                      3 ; Version 3.5.0 #9253 (Apr  3 2018) (Linux)
                                      4 ; This file was generated Sat Nov  7 00:47:04 2020
                                      5 ;--------------------------------------------------------
                                      6 	.module clock
                                      7 	.optsdcc -mstm8
                                      8 	
                                      9 ;--------------------------------------------------------
                                     10 ; Public variables in this module
                                     11 ;--------------------------------------------------------
                                     12 	.globl _main
                                     13 	.globl _EEPROM_UNLOCK
                                     14 	.globl _transTime
                                     15 	.globl _conSec
                                     16 	.globl _RTC_Set
                                     17 	.globl _RTC_Read
                                     18 	.globl _i2c_read_byte
                                     19 	.globl _i2c_send_byte
                                     20 	.globl _i2c_init
                                     21 	.globl _i2c_restart
                                     22 	.globl _i2c_start
                                     23 	.globl _i2c_stop
                                     24 	.globl _TM1637_cleer
                                     25 	.globl _TM1637_send
                                     26 	.globl _TM1637_brigh
                                     27 	.globl _TM1637_initialization
                                     28 	.globl _buff
                                     29 	.globl _auto_exit
                                     30 	.globl _Buff_But
                                     31 	.globl _Point_Meny
                                     32 	.globl _Soft_Timer
                                     33 	.globl _con_sec
                                     34 	.globl _con_min
                                     35 	.globl _con_hour
                                     36 	.globl _con_day
                                     37 	.globl _ASCI
                                     38 	.globl _TM1637_seg
                                     39 	.globl _command2
                                     40 	.globl _command1
                                     41 	.globl _brigh
                                     42 	.globl _PointTimer
                                     43 	.globl _timeRes
                                     44 	.globl _timeToSec
                                     45 	.globl _DnClock_Tim_3
                                     46 	.globl _DnClock_Tim_2
                                     47 	.globl _DnClock_Tim_1
                                     48 	.globl _DnClock_Tim_0
                                     49 	.globl _Clock_Temp
                                     50 	.globl _dot
                                     51 	.globl _year
                                     52 	.globl _month
                                     53 	.globl _date
                                     54 	.globl _day
                                     55 	.globl _hour
                                     56 	.globl _min
                                     57 	.globl _sec
                                     58 	.globl _defStart
                                     59 	.globl _setStat
                                     60 	.globl _button
                                     61 	.globl _hard_Reset
                                     62 	.globl _Set_time
                                     63 	.globl _Set_Brigh
                                     64 	.globl _Set_DnTimer
                                     65 	.globl _Set_Meny
                                     66 	.globl _Meny
                                     67 	.globl _clock
                                     68 	.globl _dnClock
                                     69 ;--------------------------------------------------------
                                     70 ; ram data
                                     71 ;--------------------------------------------------------
                                     72 	.area DATA
      000000                         73 _sec::
      000000                         74 	.ds 1
      000001                         75 _min::
      000001                         76 	.ds 1
      000002                         77 _hour::
      000002                         78 	.ds 1
      000003                         79 _day::
      000003                         80 	.ds 1
      000004                         81 _date::
      000004                         82 	.ds 1
      000005                         83 _month::
      000005                         84 	.ds 1
      000006                         85 _year::
      000006                         86 	.ds 1
      000007                         87 _dot::
      000007                         88 	.ds 1
      000008                         89 _Clock_Temp::
      000008                         90 	.ds 2
      00000A                         91 _DnClock_Tim_0::
      00000A                         92 	.ds 4
      00000E                         93 _DnClock_Tim_1::
      00000E                         94 	.ds 4
      000012                         95 _DnClock_Tim_2::
      000012                         96 	.ds 4
      000016                         97 _DnClock_Tim_3::
      000016                         98 	.ds 4
      00001A                         99 _timeToSec::
      00001A                        100 	.ds 4
      00001E                        101 _timeRes::
      00001E                        102 	.ds 4
      000022                        103 _PointTimer::
      000022                        104 	.ds 1
                                    105 ;--------------------------------------------------------
                                    106 ; ram data
                                    107 ;--------------------------------------------------------
                                    108 	.area INITIALIZED
      000000                        109 _brigh::
      000000                        110 	.ds 1
      000001                        111 _command1::
      000001                        112 	.ds 1
      000002                        113 _command2::
      000002                        114 	.ds 1
      000003                        115 _TM1637_seg::
      000003                        116 	.ds 4
      000007                        117 _ASCI::
      000007                        118 	.ds 10
      000011                        119 _con_day::
      000011                        120 	.ds 4
      000015                        121 _con_hour::
      000015                        122 	.ds 4
      000019                        123 _con_min::
      000019                        124 	.ds 4
      00001D                        125 _con_sec::
      00001D                        126 	.ds 4
      000021                        127 _Soft_Timer::
      000021                        128 	.ds 2
      000023                        129 _Point_Meny::
      000023                        130 	.ds 2
      000025                        131 _Buff_But::
      000025                        132 	.ds 1
      000026                        133 _auto_exit::
      000026                        134 	.ds 1
      000027                        135 _buff::
      000027                        136 	.ds 1
                                    137 ;--------------------------------------------------------
                                    138 ; Stack segment in internal ram 
                                    139 ;--------------------------------------------------------
                                    140 	.area	SSEG
      000000                        141 __start__stack:
      000000                        142 	.ds	1
                                    143 
                                    144 ;--------------------------------------------------------
                                    145 ; absolute external ram data
                                    146 ;--------------------------------------------------------
                                    147 	.area DABS (ABS)
                                    148 ;--------------------------------------------------------
                                    149 ; interrupt vector 
                                    150 ;--------------------------------------------------------
                                    151 	.area HOME
      000000                        152 __interrupt_vect:
      000000 82v00u00u00            153 	int s_GSINIT ;reset
      000004 82 00 00 00            154 	int 0x0000 ;trap
      000008 82 00 00 00            155 	int 0x0000 ;int0
      00000C 82 00 00 00            156 	int 0x0000 ;int1
      000010 82 00 00 00            157 	int 0x0000 ;int2
      000014 82 00 00 00            158 	int 0x0000 ;int3
      000018 82 00 00 00            159 	int 0x0000 ;int4
      00001C 82 00 00 00            160 	int 0x0000 ;int5
      000020 82 00 00 00            161 	int 0x0000 ;int6
      000024 82 00 00 00            162 	int 0x0000 ;int7
      000028 82 00 00 00            163 	int 0x0000 ;int8
      00002C 82 00 00 00            164 	int 0x0000 ;int9
      000030 82 00 00 00            165 	int 0x0000 ;int10
      000034 82 00 00 00            166 	int 0x0000 ;int11
      000038 82 00 00 00            167 	int 0x0000 ;int12
      00003C 82 00 00 00            168 	int 0x0000 ;int13
      000040 82 00 00 00            169 	int 0x0000 ;int14
      000044 82 00 00 00            170 	int 0x0000 ;int15
      000048 82 00 00 00            171 	int 0x0000 ;int16
      00004C 82 00 00 00            172 	int 0x0000 ;int17
      000050 82 00 00 00            173 	int 0x0000 ;int18
      000054 82 00 00 00            174 	int 0x0000 ;int19
      000058 82 00 00 00            175 	int 0x0000 ;int20
      00005C 82 00 00 00            176 	int 0x0000 ;int21
      000060 82 00 00 00            177 	int 0x0000 ;int22
      000064 82 00 00 00            178 	int 0x0000 ;int23
      000068 82 00 00 00            179 	int 0x0000 ;int24
      00006C 82 00 00 00            180 	int 0x0000 ;int25
      000070 82 00 00 00            181 	int 0x0000 ;int26
      000074 82 00 00 00            182 	int 0x0000 ;int27
      000078 82 00 00 00            183 	int 0x0000 ;int28
      00007C 82 00 00 00            184 	int 0x0000 ;int29
                                    185 ;--------------------------------------------------------
                                    186 ; global & static initialisations
                                    187 ;--------------------------------------------------------
                                    188 	.area HOME
                                    189 	.area GSINIT
                                    190 	.area GSFINAL
                                    191 	.area GSINIT
      000000                        192 __sdcc_gs_init_startup:
      000000                        193 __sdcc_init_data:
                                    194 ; stm8_genXINIT() start
      000000 AEr00r00         [ 2]  195 	ldw x, #l_DATA
      000003 27 07            [ 1]  196 	jreq	00002$
      000005                        197 00001$:
      000005 72 4FuFFuFF      [ 1]  198 	clr (s_DATA - 1, x)
      000009 5A               [ 2]  199 	decw x
      00000A 26 F9            [ 1]  200 	jrne	00001$
      00000C                        201 00002$:
      00000C AEr00r00         [ 2]  202 	ldw	x, #l_INITIALIZER
      00000F 27 09            [ 1]  203 	jreq	00004$
      000011                        204 00003$:
      000011 D6uFFuFF         [ 1]  205 	ld	a, (s_INITIALIZER - 1, x)
      000014 D7uFFuFF         [ 1]  206 	ld	(s_INITIALIZED - 1, x), a
      000017 5A               [ 2]  207 	decw	x
      000018 26 F7            [ 1]  208 	jrne	00003$
      00001A                        209 00004$:
                                    210 ; stm8_genXINIT() end
                                    211 	.area GSFINAL
      000000 CCr00r80         [ 2]  212 	jp	__sdcc_program_startup
                                    213 ;--------------------------------------------------------
                                    214 ; Home
                                    215 ;--------------------------------------------------------
                                    216 	.area HOME
                                    217 	.area HOME
      000080                        218 __sdcc_program_startup:
      000080 CCr08r19         [ 2]  219 	jp	_main
                                    220 ;	return from main will return to caller
                                    221 ;--------------------------------------------------------
                                    222 ; code
                                    223 ;--------------------------------------------------------
                                    224 	.area CODE
                                    225 ;	lib/stm8.h: 4: static void delay(unsigned long t)
                                    226 ;	-----------------------------------------
                                    227 ;	 function delay
                                    228 ;	-----------------------------------------
      000000                        229 _delay:
      000000 52 08            [ 2]  230 	sub	sp, #8
                                    231 ;	lib/stm8.h: 6: while(t--){
      000002 16 0B            [ 2]  232 	ldw	y, (0x0b, sp)
      000004 17 01            [ 2]  233 	ldw	(0x01, sp), y
      000006 1E 0D            [ 2]  234 	ldw	x, (0x0d, sp)
      000008                        235 00101$:
      000008 41               [ 1]  236 	exg	a, xl
      000009 6B 08            [ 1]  237 	ld	(0x08, sp), a
      00000B 41               [ 1]  238 	exg	a, xl
      00000C 16 01            [ 2]  239 	ldw	y, (0x01, sp)
      00000E 17 05            [ 2]  240 	ldw	(0x05, sp), y
      000010 9E               [ 1]  241 	ld	a, xh
      000011 1D 00 01         [ 2]  242 	subw	x, #0x0001
      000014 88               [ 1]  243 	push	a
      000015 7B 03            [ 1]  244 	ld	a, (0x03, sp)
      000017 A2 00            [ 1]  245 	sbc	a, #0x00
      000019 6B 03            [ 1]  246 	ld	(0x03, sp), a
      00001B 7B 02            [ 1]  247 	ld	a, (0x02, sp)
      00001D A2 00            [ 1]  248 	sbc	a, #0x00
      00001F 6B 02            [ 1]  249 	ld	(0x02, sp), a
      000021 84               [ 1]  250 	pop	a
      000022 0D 08            [ 1]  251 	tnz	(0x08, sp)
      000024 26 07            [ 1]  252 	jrne	00115$
      000026 4D               [ 1]  253 	tnz	a
      000027 26 04            [ 1]  254 	jrne	00115$
      000029 16 05            [ 2]  255 	ldw	y, (0x05, sp)
      00002B 27 04            [ 1]  256 	jreq	00104$
      00002D                        257 00115$:
                                    258 ;	lib/stm8.h: 10: __endasm;
      00002D 9D               [ 1]  259 	nop
      00002E 9D               [ 1]  260 	nop
      00002F 20 D7            [ 2]  261 	jra	00101$
      000031                        262 00104$:
      000031 5B 08            [ 2]  263 	addw	sp, #8
      000033 81               [ 4]  264 	ret
                                    265 ;	lib/TM1637.c: 27: void TM1637_start(){
                                    266 ;	-----------------------------------------
                                    267 ;	 function TM1637_start
                                    268 ;	-----------------------------------------
      000034                        269 _TM1637_start:
                                    270 ;	lib/TM1637.c: 28: TM1637_ODR |= 1<<TM1637_SCL;
      000034 AE 50 0A         [ 2]  271 	ldw	x, #0x500a
      000037 F6               [ 1]  272 	ld	a, (x)
      000038 AA 08            [ 1]  273 	or	a, #0x08
      00003A F7               [ 1]  274 	ld	(x), a
                                    275 ;	lib/TM1637.c: 29: TM1637_ODR |= 1<<TM1637_SDA;
      00003B AE 50 0A         [ 2]  276 	ldw	x, #0x500a
      00003E F6               [ 1]  277 	ld	a, (x)
      00003F AA 10            [ 1]  278 	or	a, #0x10
      000041 F7               [ 1]  279 	ld	(x), a
                                    280 ;	lib/TM1637.c: 30: TM1637_DELAY();
      000042 4B 05            [ 1]  281 	push	#0x05
      000044 5F               [ 1]  282 	clrw	x
      000045 89               [ 2]  283 	pushw	x
      000046 4B 00            [ 1]  284 	push	#0x00
      000048 CDr00r00         [ 4]  285 	call	_delay
      00004B 5B 04            [ 2]  286 	addw	sp, #4
                                    287 ;	lib/TM1637.c: 31: TM1637_ODR &= ~(1<<TM1637_SDA);
      00004D AE 50 0A         [ 2]  288 	ldw	x, #0x500a
      000050 F6               [ 1]  289 	ld	a, (x)
      000051 A4 EF            [ 1]  290 	and	a, #0xef
      000053 F7               [ 1]  291 	ld	(x), a
      000054 81               [ 4]  292 	ret
                                    293 ;	lib/TM1637.c: 34: void TM1637_stop(){
                                    294 ;	-----------------------------------------
                                    295 ;	 function TM1637_stop
                                    296 ;	-----------------------------------------
      000055                        297 _TM1637_stop:
                                    298 ;	lib/TM1637.c: 35: TM1637_ODR &= ~(1<<TM1637_SCL);
      000055 AE 50 0A         [ 2]  299 	ldw	x, #0x500a
      000058 F6               [ 1]  300 	ld	a, (x)
      000059 A4 F7            [ 1]  301 	and	a, #0xf7
      00005B F7               [ 1]  302 	ld	(x), a
                                    303 ;	lib/TM1637.c: 36: TM1637_DELAY();
      00005C 4B 05            [ 1]  304 	push	#0x05
      00005E 5F               [ 1]  305 	clrw	x
      00005F 89               [ 2]  306 	pushw	x
      000060 4B 00            [ 1]  307 	push	#0x00
      000062 CDr00r00         [ 4]  308 	call	_delay
      000065 5B 04            [ 2]  309 	addw	sp, #4
                                    310 ;	lib/TM1637.c: 37: TM1637_ODR &= ~(1<<TM1637_SDA);
      000067 AE 50 0A         [ 2]  311 	ldw	x, #0x500a
      00006A F6               [ 1]  312 	ld	a, (x)
      00006B A4 EF            [ 1]  313 	and	a, #0xef
      00006D F7               [ 1]  314 	ld	(x), a
                                    315 ;	lib/TM1637.c: 38: TM1637_DELAY();
      00006E 4B 05            [ 1]  316 	push	#0x05
      000070 5F               [ 1]  317 	clrw	x
      000071 89               [ 2]  318 	pushw	x
      000072 4B 00            [ 1]  319 	push	#0x00
      000074 CDr00r00         [ 4]  320 	call	_delay
      000077 5B 04            [ 2]  321 	addw	sp, #4
                                    322 ;	lib/TM1637.c: 39: TM1637_ODR |= 1<<TM1637_SCL;;
      000079 AE 50 0A         [ 2]  323 	ldw	x, #0x500a
      00007C F6               [ 1]  324 	ld	a, (x)
      00007D AA 08            [ 1]  325 	or	a, #0x08
      00007F F7               [ 1]  326 	ld	(x), a
                                    327 ;	lib/TM1637.c: 40: TM1637_DELAY();
      000080 4B 05            [ 1]  328 	push	#0x05
      000082 5F               [ 1]  329 	clrw	x
      000083 89               [ 2]  330 	pushw	x
      000084 4B 00            [ 1]  331 	push	#0x00
      000086 CDr00r00         [ 4]  332 	call	_delay
      000089 5B 04            [ 2]  333 	addw	sp, #4
                                    334 ;	lib/TM1637.c: 41: TM1637_ODR |= 1<<TM1637_SDA;
      00008B AE 50 0A         [ 2]  335 	ldw	x, #0x500a
      00008E F6               [ 1]  336 	ld	a, (x)
      00008F AA 10            [ 1]  337 	or	a, #0x10
      000091 F7               [ 1]  338 	ld	(x), a
      000092 81               [ 4]  339 	ret
                                    340 ;	lib/TM1637.c: 45: void TM1637_writeByte(char pack){
                                    341 ;	-----------------------------------------
                                    342 ;	 function TM1637_writeByte
                                    343 ;	-----------------------------------------
      000093                        344 _TM1637_writeByte:
      000093 88               [ 1]  345 	push	a
                                    346 ;	lib/TM1637.c: 48: for(i=0;i<8;i++)  
      000094 0F 01            [ 1]  347 	clr	(0x01, sp)
      000096                        348 00108$:
                                    349 ;	lib/TM1637.c: 50: TM1637_ODR &= ~(1<<TM1637_SCL);
      000096 AE 50 0A         [ 2]  350 	ldw	x, #0x500a
      000099 F6               [ 1]  351 	ld	a, (x)
      00009A A4 F7            [ 1]  352 	and	a, #0xf7
      00009C F7               [ 1]  353 	ld	(x), a
      00009D AE 50 0A         [ 2]  354 	ldw	x, #0x500a
      0000A0 F6               [ 1]  355 	ld	a, (x)
                                    356 ;	lib/TM1637.c: 51: if(pack & 0x01)
      0000A1 88               [ 1]  357 	push	a
      0000A2 7B 05            [ 1]  358 	ld	a, (0x05, sp)
      0000A4 44               [ 1]  359 	srl	a
      0000A5 84               [ 1]  360 	pop	a
      0000A6 24 08            [ 1]  361 	jrnc	00102$
                                    362 ;	lib/TM1637.c: 52: { TM1637_ODR |= 1<<TM1637_SDA;}
      0000A8 AA 10            [ 1]  363 	or	a, #0x10
      0000AA AE 50 0A         [ 2]  364 	ldw	x, #0x500a
      0000AD F7               [ 1]  365 	ld	(x), a
      0000AE 20 06            [ 2]  366 	jra	00103$
      0000B0                        367 00102$:
                                    368 ;	lib/TM1637.c: 53: else {TM1637_ODR &= ~(1<<TM1637_SDA);}
      0000B0 A4 EF            [ 1]  369 	and	a, #0xef
      0000B2 AE 50 0A         [ 2]  370 	ldw	x, #0x500a
      0000B5 F7               [ 1]  371 	ld	(x), a
      0000B6                        372 00103$:
                                    373 ;	lib/TM1637.c: 54: TM1637_DELAY();
      0000B6 4B 05            [ 1]  374 	push	#0x05
      0000B8 5F               [ 1]  375 	clrw	x
      0000B9 89               [ 2]  376 	pushw	x
      0000BA 4B 00            [ 1]  377 	push	#0x00
      0000BC CDr00r00         [ 4]  378 	call	_delay
      0000BF 5B 04            [ 2]  379 	addw	sp, #4
                                    380 ;	lib/TM1637.c: 55: pack = pack >> 1;
      0000C1 07 04            [ 1]  381 	sra	(0x04, sp)
                                    382 ;	lib/TM1637.c: 56: TM1637_ODR |= 1<<TM1637_SCL;
      0000C3 AE 50 0A         [ 2]  383 	ldw	x, #0x500a
      0000C6 F6               [ 1]  384 	ld	a, (x)
      0000C7 AA 08            [ 1]  385 	or	a, #0x08
      0000C9 F7               [ 1]  386 	ld	(x), a
                                    387 ;	lib/TM1637.c: 57: TM1637_DELAY();
      0000CA 4B 05            [ 1]  388 	push	#0x05
      0000CC 5F               [ 1]  389 	clrw	x
      0000CD 89               [ 2]  390 	pushw	x
      0000CE 4B 00            [ 1]  391 	push	#0x00
      0000D0 CDr00r00         [ 4]  392 	call	_delay
      0000D3 5B 04            [ 2]  393 	addw	sp, #4
                                    394 ;	lib/TM1637.c: 48: for(i=0;i<8;i++)  
      0000D5 0C 01            [ 1]  395 	inc	(0x01, sp)
      0000D7 7B 01            [ 1]  396 	ld	a, (0x01, sp)
      0000D9 A1 08            [ 1]  397 	cp	a, #0x08
      0000DB 2F B9            [ 1]  398 	jrslt	00108$
                                    399 ;	lib/TM1637.c: 59: TM1637_ODR &= ~(1<<TM1637_SCL);
      0000DD AE 50 0A         [ 2]  400 	ldw	x, #0x500a
      0000E0 F6               [ 1]  401 	ld	a, (x)
      0000E1 A4 F7            [ 1]  402 	and	a, #0xf7
      0000E3 F7               [ 1]  403 	ld	(x), a
                                    404 ;	lib/TM1637.c: 60: TM1637_DELAY();
      0000E4 4B 05            [ 1]  405 	push	#0x05
      0000E6 5F               [ 1]  406 	clrw	x
      0000E7 89               [ 2]  407 	pushw	x
      0000E8 4B 00            [ 1]  408 	push	#0x00
      0000EA CDr00r00         [ 4]  409 	call	_delay
      0000ED 5B 04            [ 2]  410 	addw	sp, #4
                                    411 ;	lib/TM1637.c: 61: TM1637_DDR &= ~(1<<TM1637_SDA);
      0000EF AE 50 0C         [ 2]  412 	ldw	x, #0x500c
      0000F2 F6               [ 1]  413 	ld	a, (x)
      0000F3 A4 EF            [ 1]  414 	and	a, #0xef
      0000F5 F7               [ 1]  415 	ld	(x), a
                                    416 ;	lib/TM1637.c: 62: while((TM1637_IDR & (1<<TM1637_SDA)));
      0000F6                        417 00105$:
      0000F6 AE 50 0B         [ 2]  418 	ldw	x, #0x500b
      0000F9 F6               [ 1]  419 	ld	a, (x)
      0000FA A5 10            [ 1]  420 	bcp	a, #0x10
      0000FC 26 F8            [ 1]  421 	jrne	00105$
                                    422 ;	lib/TM1637.c: 63: TM1637_DDR |= (1<<TM1637_SDA);
      0000FE AE 50 0C         [ 2]  423 	ldw	x, #0x500c
      000101 F6               [ 1]  424 	ld	a, (x)
      000102 AA 10            [ 1]  425 	or	a, #0x10
      000104 F7               [ 1]  426 	ld	(x), a
                                    427 ;	lib/TM1637.c: 64: TM1637_ODR |= 1<<TM1637_SCL;
      000105 AE 50 0A         [ 2]  428 	ldw	x, #0x500a
      000108 F6               [ 1]  429 	ld	a, (x)
      000109 AA 08            [ 1]  430 	or	a, #0x08
      00010B F7               [ 1]  431 	ld	(x), a
                                    432 ;	lib/TM1637.c: 65: TM1637_DELAY();
      00010C 4B 05            [ 1]  433 	push	#0x05
      00010E 5F               [ 1]  434 	clrw	x
      00010F 89               [ 2]  435 	pushw	x
      000110 4B 00            [ 1]  436 	push	#0x00
      000112 CDr00r00         [ 4]  437 	call	_delay
      000115 5B 04            [ 2]  438 	addw	sp, #4
                                    439 ;	lib/TM1637.c: 66: TM1637_ODR &= ~(1<<TM1637_SCL);
      000117 AE 50 0A         [ 2]  440 	ldw	x, #0x500a
      00011A F6               [ 1]  441 	ld	a, (x)
      00011B A4 F7            [ 1]  442 	and	a, #0xf7
      00011D F7               [ 1]  443 	ld	(x), a
      00011E 84               [ 1]  444 	pop	a
      00011F 81               [ 4]  445 	ret
                                    446 ;	lib/TM1637.c: 70: void TM1637_brigh(char brigh){
                                    447 ;	-----------------------------------------
                                    448 ;	 function TM1637_brigh
                                    449 ;	-----------------------------------------
      000120                        450 _TM1637_brigh:
                                    451 ;	lib/TM1637.c: 71: if(brigh>7)brigh = 7;
      000120 7B 03            [ 1]  452 	ld	a, (0x03, sp)
      000122 A1 07            [ 1]  453 	cp	a, #0x07
      000124 2D 04            [ 1]  454 	jrsle	00102$
      000126 A6 07            [ 1]  455 	ld	a, #0x07
      000128 6B 03            [ 1]  456 	ld	(0x03, sp), a
      00012A                        457 00102$:
                                    458 ;	lib/TM1637.c: 73: TM1637_start();
      00012A CDr00r34         [ 4]  459 	call	_TM1637_start
                                    460 ;	lib/TM1637.c: 74: TM1637_writeByte(0x88 + brigh); //Команда, задающая яркость дисплея
      00012D 7B 03            [ 1]  461 	ld	a, (0x03, sp)
      00012F AB 88            [ 1]  462 	add	a, #0x88
      000131 88               [ 1]  463 	push	a
      000132 CDr00r93         [ 4]  464 	call	_TM1637_writeByte
      000135 84               [ 1]  465 	pop	a
                                    466 ;	lib/TM1637.c: 75: TM1637_stop();
      000136 CCr00r55         [ 2]  467 	jp	_TM1637_stop
                                    468 ;	lib/TM1637.c: 78: void TM1637_send(){
                                    469 ;	-----------------------------------------
                                    470 ;	 function TM1637_send
                                    471 ;	-----------------------------------------
      000139                        472 _TM1637_send:
      000139 52 02            [ 2]  473 	sub	sp, #2
                                    474 ;	lib/TM1637.c: 80: TM1637_start();                  
      00013B CDr00r34         [ 4]  475 	call	_TM1637_start
                                    476 ;	lib/TM1637.c: 81: TM1637_writeByte(command1);			//Команда записи в регистр дисплея
      00013E 3Bu00u01         [ 1]  477 	push	_command1+0
      000141 CDr00r93         [ 4]  478 	call	_TM1637_writeByte
      000144 84               [ 1]  479 	pop	a
                                    480 ;	lib/TM1637.c: 82: TM1637_stop();
      000145 CDr00r55         [ 4]  481 	call	_TM1637_stop
                                    482 ;	lib/TM1637.c: 84: TM1637_start();
      000148 CDr00r34         [ 4]  483 	call	_TM1637_start
                                    484 ;	lib/TM1637.c: 85: TM1637_writeByte(command2); //Команда начального адреса для автоинкремента адреса
      00014B 3Bu00u02         [ 1]  485 	push	_command2+0
      00014E CDr00r93         [ 4]  486 	call	_TM1637_writeByte
      000151 84               [ 1]  487 	pop	a
                                    488 ;	lib/TM1637.c: 87: TM1637_writeByte(TM1637_seg[0]);
      000152 AEr00r03         [ 2]  489 	ldw	x, #_TM1637_seg+0
      000155 1F 01            [ 2]  490 	ldw	(0x01, sp), x
      000157 1E 01            [ 2]  491 	ldw	x, (0x01, sp)
      000159 F6               [ 1]  492 	ld	a, (x)
      00015A 88               [ 1]  493 	push	a
      00015B CDr00r93         [ 4]  494 	call	_TM1637_writeByte
      00015E 84               [ 1]  495 	pop	a
                                    496 ;	lib/TM1637.c: 88: TM1637_writeByte(TM1637_seg[1]);
      00015F 1E 01            [ 2]  497 	ldw	x, (0x01, sp)
      000161 E6 01            [ 1]  498 	ld	a, (0x1, x)
      000163 88               [ 1]  499 	push	a
      000164 CDr00r93         [ 4]  500 	call	_TM1637_writeByte
      000167 84               [ 1]  501 	pop	a
                                    502 ;	lib/TM1637.c: 89: TM1637_writeByte(TM1637_seg[2]);
      000168 1E 01            [ 2]  503 	ldw	x, (0x01, sp)
      00016A E6 02            [ 1]  504 	ld	a, (0x2, x)
      00016C 88               [ 1]  505 	push	a
      00016D CDr00r93         [ 4]  506 	call	_TM1637_writeByte
      000170 84               [ 1]  507 	pop	a
                                    508 ;	lib/TM1637.c: 90: TM1637_writeByte(TM1637_seg[3]);
      000171 1E 01            [ 2]  509 	ldw	x, (0x01, sp)
      000173 E6 03            [ 1]  510 	ld	a, (0x3, x)
      000175 88               [ 1]  511 	push	a
      000176 CDr00r93         [ 4]  512 	call	_TM1637_writeByte
      000179 84               [ 1]  513 	pop	a
                                    514 ;	lib/TM1637.c: 92: TM1637_stop();
      00017A CDr00r55         [ 4]  515 	call	_TM1637_stop
      00017D 5B 02            [ 2]  516 	addw	sp, #2
      00017F 81               [ 4]  517 	ret
                                    518 ;	lib/TM1637.c: 95: void TM1637_cleer(){
                                    519 ;	-----------------------------------------
                                    520 ;	 function TM1637_cleer
                                    521 ;	-----------------------------------------
      000180                        522 _TM1637_cleer:
      000180 52 02            [ 2]  523 	sub	sp, #2
                                    524 ;	lib/TM1637.c: 96: TM1637_seg[0] = 0x00;
      000182 AEr00r03         [ 2]  525 	ldw	x, #_TM1637_seg+0
      000185 1F 01            [ 2]  526 	ldw	(0x01, sp), x
      000187 1E 01            [ 2]  527 	ldw	x, (0x01, sp)
      000189 7F               [ 1]  528 	clr	(x)
                                    529 ;	lib/TM1637.c: 97: TM1637_seg[1] = 0x00;
      00018A 1E 01            [ 2]  530 	ldw	x, (0x01, sp)
      00018C 5C               [ 2]  531 	incw	x
      00018D 7F               [ 1]  532 	clr	(x)
                                    533 ;	lib/TM1637.c: 98: TM1637_seg[2] = 0x00;
      00018E 1E 01            [ 2]  534 	ldw	x, (0x01, sp)
      000190 5C               [ 2]  535 	incw	x
      000191 5C               [ 2]  536 	incw	x
      000192 7F               [ 1]  537 	clr	(x)
                                    538 ;	lib/TM1637.c: 99: TM1637_seg[3] = 0x00;
      000193 1E 01            [ 2]  539 	ldw	x, (0x01, sp)
      000195 1C 00 03         [ 2]  540 	addw	x, #0x0003
      000198 7F               [ 1]  541 	clr	(x)
                                    542 ;	lib/TM1637.c: 100: TM1637_send();
      000199 CDr01r39         [ 4]  543 	call	_TM1637_send
      00019C 5B 02            [ 2]  544 	addw	sp, #2
      00019E 81               [ 4]  545 	ret
                                    546 ;	lib/TM1637.c: 103: void TM1637_initialization(){
                                    547 ;	-----------------------------------------
                                    548 ;	 function TM1637_initialization
                                    549 ;	-----------------------------------------
      00019F                        550 _TM1637_initialization:
                                    551 ;	lib/TM1637.c: 104: TM1637_ODR |= (1<<TM1637_SCL) | (1<<TM1637_SDA); 
      00019F AE 50 0A         [ 2]  552 	ldw	x, #0x500a
      0001A2 F6               [ 1]  553 	ld	a, (x)
      0001A3 AA 18            [ 1]  554 	or	a, #0x18
      0001A5 F7               [ 1]  555 	ld	(x), a
                                    556 ;	lib/TM1637.c: 107: TM1637_cleer();
      0001A6 CCr01r80         [ 2]  557 	jp	_TM1637_cleer
                                    558 ;	lib/TM1637.c: 110: void TM1637_dot(char d){
                                    559 ;	-----------------------------------------
                                    560 ;	 function TM1637_dot
                                    561 ;	-----------------------------------------
      0001A9                        562 _TM1637_dot:
                                    563 ;	lib/TM1637.c: 111: if(d == 1)TM1637_seg[1] = TM1637_seg[1] + 0x80; 
      0001A9 7B 03            [ 1]  564 	ld	a, (0x03, sp)
      0001AB A1 01            [ 1]  565 	cp	a, #0x01
      0001AD 26 07            [ 1]  566 	jrne	00103$
      0001AF AEr00r04         [ 2]  567 	ldw	x, #_TM1637_seg+1
      0001B2 F6               [ 1]  568 	ld	a, (x)
      0001B3 AB 80            [ 1]  569 	add	a, #0x80
      0001B5 F7               [ 1]  570 	ld	(x), a
      0001B6                        571 00103$:
      0001B6 81               [ 4]  572 	ret
                                    573 ;	lib/i2c.c: 16: unsigned char i2c_stop(void)
                                    574 ;	-----------------------------------------
                                    575 ;	 function i2c_stop
                                    576 ;	-----------------------------------------
      0001B7                        577 _i2c_stop:
      0001B7 88               [ 1]  578 	push	a
                                    579 ;	lib/i2c.c: 18: unsigned char error = 0;
      0001B8 0F 01            [ 1]  580 	clr	(0x01, sp)
                                    581 ;	lib/i2c.c: 20: NULL_SCL();
      0001BA AE 50 07         [ 2]  582 	ldw	x, #0x5007
      0001BD F6               [ 1]  583 	ld	a, (x)
      0001BE AA 10            [ 1]  584 	or	a, #0x10
      0001C0 F7               [ 1]  585 	ld	(x), a
      0001C1 AE 50 05         [ 2]  586 	ldw	x, #0x5005
      0001C4 F6               [ 1]  587 	ld	a, (x)
      0001C5 A4 EF            [ 1]  588 	and	a, #0xef
      0001C7 F7               [ 1]  589 	ld	(x), a
                                    590 ;	lib/i2c.c: 21: I2C_DELAY();
      0001C8 4B 05            [ 1]  591 	push	#0x05
      0001CA 5F               [ 1]  592 	clrw	x
      0001CB 89               [ 2]  593 	pushw	x
      0001CC 4B 00            [ 1]  594 	push	#0x00
      0001CE CDr00r00         [ 4]  595 	call	_delay
      0001D1 5B 04            [ 2]  596 	addw	sp, #4
                                    597 ;	lib/i2c.c: 22: NULL_SDA();
      0001D3 AE 50 07         [ 2]  598 	ldw	x, #0x5007
      0001D6 F6               [ 1]  599 	ld	a, (x)
      0001D7 AA 20            [ 1]  600 	or	a, #0x20
      0001D9 F7               [ 1]  601 	ld	(x), a
      0001DA AE 50 05         [ 2]  602 	ldw	x, #0x5005
      0001DD F6               [ 1]  603 	ld	a, (x)
      0001DE A4 DF            [ 1]  604 	and	a, #0xdf
      0001E0 F7               [ 1]  605 	ld	(x), a
                                    606 ;	lib/i2c.c: 23: I2C_DELAY();
      0001E1 4B 05            [ 1]  607 	push	#0x05
      0001E3 5F               [ 1]  608 	clrw	x
      0001E4 89               [ 2]  609 	pushw	x
      0001E5 4B 00            [ 1]  610 	push	#0x00
      0001E7 CDr00r00         [ 4]  611 	call	_delay
      0001EA 5B 04            [ 2]  612 	addw	sp, #4
                                    613 ;	lib/i2c.c: 25: ONE_SCL();
      0001EC AE 50 07         [ 2]  614 	ldw	x, #0x5007
      0001EF F6               [ 1]  615 	ld	a, (x)
      0001F0 A4 EF            [ 1]  616 	and	a, #0xef
      0001F2 F7               [ 1]  617 	ld	(x), a
      0001F3 AE 50 05         [ 2]  618 	ldw	x, #0x5005
      0001F6 F6               [ 1]  619 	ld	a, (x)
      0001F7 AA 10            [ 1]  620 	or	a, #0x10
      0001F9 F7               [ 1]  621 	ld	(x), a
                                    622 ;	lib/i2c.c: 26: I2C_DELAY();
      0001FA 4B 05            [ 1]  623 	push	#0x05
      0001FC 5F               [ 1]  624 	clrw	x
      0001FD 89               [ 2]  625 	pushw	x
      0001FE 4B 00            [ 1]  626 	push	#0x00
      000200 CDr00r00         [ 4]  627 	call	_delay
      000203 5B 04            [ 2]  628 	addw	sp, #4
                                    629 ;	lib/i2c.c: 27: ONE_SDA();
      000205 AE 50 07         [ 2]  630 	ldw	x, #0x5007
      000208 F6               [ 1]  631 	ld	a, (x)
      000209 A4 DF            [ 1]  632 	and	a, #0xdf
      00020B F7               [ 1]  633 	ld	(x), a
      00020C AE 50 05         [ 2]  634 	ldw	x, #0x5005
      00020F F6               [ 1]  635 	ld	a, (x)
      000210 AA 20            [ 1]  636 	or	a, #0x20
      000212 F7               [ 1]  637 	ld	(x), a
                                    638 ;	lib/i2c.c: 28: I2C_DELAY();
      000213 4B 05            [ 1]  639 	push	#0x05
      000215 5F               [ 1]  640 	clrw	x
      000216 89               [ 2]  641 	pushw	x
      000217 4B 00            [ 1]  642 	push	#0x00
      000219 CDr00r00         [ 4]  643 	call	_delay
      00021C 5B 04            [ 2]  644 	addw	sp, #4
                                    645 ;	lib/i2c.c: 30: if((I2C_IDR & (1 << I2C_SDA)) == 0) error = 2;
      00021E AE 50 06         [ 2]  646 	ldw	x, #0x5006
      000221 F6               [ 1]  647 	ld	a, (x)
      000222 A5 20            [ 1]  648 	bcp	a, #0x20
      000224 26 06            [ 1]  649 	jrne	00102$
      000226 88               [ 1]  650 	push	a
      000227 A6 02            [ 1]  651 	ld	a, #0x02
      000229 6B 02            [ 1]  652 	ld	(0x02, sp), a
      00022B 84               [ 1]  653 	pop	a
      00022C                        654 00102$:
                                    655 ;	lib/i2c.c: 31: if((I2C_IDR & (1 << I2C_SCL)) == 0) error |= 1;
      00022C A5 10            [ 1]  656 	bcp	a, #0x10
      00022E 26 06            [ 1]  657 	jrne	00104$
      000230 7B 01            [ 1]  658 	ld	a, (0x01, sp)
      000232 AA 01            [ 1]  659 	or	a, #0x01
      000234 6B 01            [ 1]  660 	ld	(0x01, sp), a
      000236                        661 00104$:
                                    662 ;	lib/i2c.c: 32: I2C_DELAY();
      000236 4B 05            [ 1]  663 	push	#0x05
      000238 5F               [ 1]  664 	clrw	x
      000239 89               [ 2]  665 	pushw	x
      00023A 4B 00            [ 1]  666 	push	#0x00
      00023C CDr00r00         [ 4]  667 	call	_delay
      00023F 5B 04            [ 2]  668 	addw	sp, #4
                                    669 ;	lib/i2c.c: 33: I2C_DELAY();
      000241 4B 05            [ 1]  670 	push	#0x05
      000243 5F               [ 1]  671 	clrw	x
      000244 89               [ 2]  672 	pushw	x
      000245 4B 00            [ 1]  673 	push	#0x00
      000247 CDr00r00         [ 4]  674 	call	_delay
      00024A 5B 04            [ 2]  675 	addw	sp, #4
                                    676 ;	lib/i2c.c: 34: I2C_DELAY();
      00024C 4B 05            [ 1]  677 	push	#0x05
      00024E 5F               [ 1]  678 	clrw	x
      00024F 89               [ 2]  679 	pushw	x
      000250 4B 00            [ 1]  680 	push	#0x00
      000252 CDr00r00         [ 4]  681 	call	_delay
      000255 5B 04            [ 2]  682 	addw	sp, #4
                                    683 ;	lib/i2c.c: 35: I2C_DELAY();
      000257 4B 05            [ 1]  684 	push	#0x05
      000259 5F               [ 1]  685 	clrw	x
      00025A 89               [ 2]  686 	pushw	x
      00025B 4B 00            [ 1]  687 	push	#0x00
      00025D CDr00r00         [ 4]  688 	call	_delay
      000260 5B 04            [ 2]  689 	addw	sp, #4
                                    690 ;	lib/i2c.c: 37: return error;
      000262 7B 01            [ 1]  691 	ld	a, (0x01, sp)
      000264 5B 01            [ 2]  692 	addw	sp, #1
      000266 81               [ 4]  693 	ret
                                    694 ;	lib/i2c.c: 44: void i2c_start(void)
                                    695 ;	-----------------------------------------
                                    696 ;	 function i2c_start
                                    697 ;	-----------------------------------------
      000267                        698 _i2c_start:
                                    699 ;	lib/i2c.c: 46: NULL_SDA();
      000267 AE 50 07         [ 2]  700 	ldw	x, #0x5007
      00026A F6               [ 1]  701 	ld	a, (x)
      00026B AA 20            [ 1]  702 	or	a, #0x20
      00026D F7               [ 1]  703 	ld	(x), a
      00026E AE 50 05         [ 2]  704 	ldw	x, #0x5005
      000271 F6               [ 1]  705 	ld	a, (x)
      000272 A4 DF            [ 1]  706 	and	a, #0xdf
      000274 F7               [ 1]  707 	ld	(x), a
                                    708 ;	lib/i2c.c: 47: I2C_DELAY();
      000275 4B 05            [ 1]  709 	push	#0x05
      000277 5F               [ 1]  710 	clrw	x
      000278 89               [ 2]  711 	pushw	x
      000279 4B 00            [ 1]  712 	push	#0x00
      00027B CDr00r00         [ 4]  713 	call	_delay
      00027E 5B 04            [ 2]  714 	addw	sp, #4
                                    715 ;	lib/i2c.c: 48: NULL_SCL();
      000280 AE 50 07         [ 2]  716 	ldw	x, #0x5007
      000283 F6               [ 1]  717 	ld	a, (x)
      000284 AA 10            [ 1]  718 	or	a, #0x10
      000286 F7               [ 1]  719 	ld	(x), a
      000287 AE 50 05         [ 2]  720 	ldw	x, #0x5005
      00028A F6               [ 1]  721 	ld	a, (x)
      00028B A4 EF            [ 1]  722 	and	a, #0xef
      00028D F7               [ 1]  723 	ld	(x), a
                                    724 ;	lib/i2c.c: 49: I2C_DELAY();
      00028E 4B 05            [ 1]  725 	push	#0x05
      000290 5F               [ 1]  726 	clrw	x
      000291 89               [ 2]  727 	pushw	x
      000292 4B 00            [ 1]  728 	push	#0x00
      000294 CDr00r00         [ 4]  729 	call	_delay
      000297 5B 04            [ 2]  730 	addw	sp, #4
      000299 81               [ 4]  731 	ret
                                    732 ;	lib/i2c.c: 56: void i2c_restart(void)
                                    733 ;	-----------------------------------------
                                    734 ;	 function i2c_restart
                                    735 ;	-----------------------------------------
      00029A                        736 _i2c_restart:
                                    737 ;	lib/i2c.c: 58: ONE_SDA();
      00029A AE 50 07         [ 2]  738 	ldw	x, #0x5007
      00029D F6               [ 1]  739 	ld	a, (x)
      00029E A4 DF            [ 1]  740 	and	a, #0xdf
      0002A0 F7               [ 1]  741 	ld	(x), a
      0002A1 AE 50 05         [ 2]  742 	ldw	x, #0x5005
      0002A4 F6               [ 1]  743 	ld	a, (x)
      0002A5 AA 20            [ 1]  744 	or	a, #0x20
      0002A7 F7               [ 1]  745 	ld	(x), a
                                    746 ;	lib/i2c.c: 59: I2C_DELAY();
      0002A8 4B 05            [ 1]  747 	push	#0x05
      0002AA 5F               [ 1]  748 	clrw	x
      0002AB 89               [ 2]  749 	pushw	x
      0002AC 4B 00            [ 1]  750 	push	#0x00
      0002AE CDr00r00         [ 4]  751 	call	_delay
      0002B1 5B 04            [ 2]  752 	addw	sp, #4
                                    753 ;	lib/i2c.c: 60: ONE_SCL();
      0002B3 AE 50 07         [ 2]  754 	ldw	x, #0x5007
      0002B6 F6               [ 1]  755 	ld	a, (x)
      0002B7 A4 EF            [ 1]  756 	and	a, #0xef
      0002B9 F7               [ 1]  757 	ld	(x), a
      0002BA AE 50 05         [ 2]  758 	ldw	x, #0x5005
      0002BD F6               [ 1]  759 	ld	a, (x)
      0002BE AA 10            [ 1]  760 	or	a, #0x10
      0002C0 F7               [ 1]  761 	ld	(x), a
                                    762 ;	lib/i2c.c: 61: I2C_DELAY();
      0002C1 4B 05            [ 1]  763 	push	#0x05
      0002C3 5F               [ 1]  764 	clrw	x
      0002C4 89               [ 2]  765 	pushw	x
      0002C5 4B 00            [ 1]  766 	push	#0x00
      0002C7 CDr00r00         [ 4]  767 	call	_delay
      0002CA 5B 04            [ 2]  768 	addw	sp, #4
                                    769 ;	lib/i2c.c: 63: NULL_SDA();
      0002CC AE 50 07         [ 2]  770 	ldw	x, #0x5007
      0002CF F6               [ 1]  771 	ld	a, (x)
      0002D0 AA 20            [ 1]  772 	or	a, #0x20
      0002D2 F7               [ 1]  773 	ld	(x), a
      0002D3 AE 50 05         [ 2]  774 	ldw	x, #0x5005
      0002D6 F6               [ 1]  775 	ld	a, (x)
      0002D7 A4 DF            [ 1]  776 	and	a, #0xdf
      0002D9 F7               [ 1]  777 	ld	(x), a
                                    778 ;	lib/i2c.c: 64: I2C_DELAY();
      0002DA 4B 05            [ 1]  779 	push	#0x05
      0002DC 5F               [ 1]  780 	clrw	x
      0002DD 89               [ 2]  781 	pushw	x
      0002DE 4B 00            [ 1]  782 	push	#0x00
      0002E0 CDr00r00         [ 4]  783 	call	_delay
      0002E3 5B 04            [ 2]  784 	addw	sp, #4
                                    785 ;	lib/i2c.c: 65: NULL_SCL();
      0002E5 AE 50 07         [ 2]  786 	ldw	x, #0x5007
      0002E8 F6               [ 1]  787 	ld	a, (x)
      0002E9 AA 10            [ 1]  788 	or	a, #0x10
      0002EB F7               [ 1]  789 	ld	(x), a
      0002EC AE 50 05         [ 2]  790 	ldw	x, #0x5005
      0002EF F6               [ 1]  791 	ld	a, (x)
      0002F0 A4 EF            [ 1]  792 	and	a, #0xef
      0002F2 F7               [ 1]  793 	ld	(x), a
                                    794 ;	lib/i2c.c: 66: I2C_DELAY();
      0002F3 4B 05            [ 1]  795 	push	#0x05
      0002F5 5F               [ 1]  796 	clrw	x
      0002F6 89               [ 2]  797 	pushw	x
      0002F7 4B 00            [ 1]  798 	push	#0x00
      0002F9 CDr00r00         [ 4]  799 	call	_delay
      0002FC 5B 04            [ 2]  800 	addw	sp, #4
      0002FE 81               [ 4]  801 	ret
                                    802 ;	lib/i2c.c: 73: void i2c_init(void)
                                    803 ;	-----------------------------------------
                                    804 ;	 function i2c_init
                                    805 ;	-----------------------------------------
      0002FF                        806 _i2c_init:
                                    807 ;	lib/i2c.c: 75: ONE_SDA();
      0002FF AE 50 07         [ 2]  808 	ldw	x, #0x5007
      000302 F6               [ 1]  809 	ld	a, (x)
      000303 A4 DF            [ 1]  810 	and	a, #0xdf
      000305 F7               [ 1]  811 	ld	(x), a
      000306 AE 50 05         [ 2]  812 	ldw	x, #0x5005
      000309 F6               [ 1]  813 	ld	a, (x)
      00030A AA 20            [ 1]  814 	or	a, #0x20
      00030C F7               [ 1]  815 	ld	(x), a
                                    816 ;	lib/i2c.c: 76: ONE_SCL();
      00030D AE 50 07         [ 2]  817 	ldw	x, #0x5007
      000310 F6               [ 1]  818 	ld	a, (x)
      000311 A4 EF            [ 1]  819 	and	a, #0xef
      000313 F7               [ 1]  820 	ld	(x), a
      000314 AE 50 05         [ 2]  821 	ldw	x, #0x5005
      000317 F6               [ 1]  822 	ld	a, (x)
      000318 AA 10            [ 1]  823 	or	a, #0x10
      00031A F7               [ 1]  824 	ld	(x), a
                                    825 ;	lib/i2c.c: 78: i2c_stop();
      00031B CCr01rB7         [ 2]  826 	jp	_i2c_stop
                                    827 ;	lib/i2c.c: 85: unsigned char i2c_send_byte(unsigned char data)
                                    828 ;	-----------------------------------------
                                    829 ;	 function i2c_send_byte
                                    830 ;	-----------------------------------------
      00031E                        831 _i2c_send_byte:
      00031E 52 02            [ 2]  832 	sub	sp, #2
                                    833 ;	lib/i2c.c: 90: for(i = 0; i < 8; i++)
      000320 0F 01            [ 1]  834 	clr	(0x01, sp)
      000322                        835 00108$:
                                    836 ;	lib/i2c.c: 94: NULL_SDA();
      000322 AE 50 07         [ 2]  837 	ldw	x, #0x5007
      000325 F6               [ 1]  838 	ld	a, (x)
                                    839 ;	lib/i2c.c: 92: if((data & 0x80) == 0)
      000326 0D 05            [ 1]  840 	tnz	(0x05, sp)
      000328 2B 0F            [ 1]  841 	jrmi	00102$
                                    842 ;	lib/i2c.c: 94: NULL_SDA();
      00032A AA 20            [ 1]  843 	or	a, #0x20
      00032C AE 50 07         [ 2]  844 	ldw	x, #0x5007
      00032F F7               [ 1]  845 	ld	(x), a
      000330 AE 50 05         [ 2]  846 	ldw	x, #0x5005
      000333 F6               [ 1]  847 	ld	a, (x)
      000334 A4 DF            [ 1]  848 	and	a, #0xdf
      000336 F7               [ 1]  849 	ld	(x), a
      000337 20 0D            [ 2]  850 	jra	00103$
      000339                        851 00102$:
                                    852 ;	lib/i2c.c: 98: ONE_SDA();
      000339 A4 DF            [ 1]  853 	and	a, #0xdf
      00033B AE 50 07         [ 2]  854 	ldw	x, #0x5007
      00033E F7               [ 1]  855 	ld	(x), a
      00033F AE 50 05         [ 2]  856 	ldw	x, #0x5005
      000342 F6               [ 1]  857 	ld	a, (x)
      000343 AA 20            [ 1]  858 	or	a, #0x20
      000345 F7               [ 1]  859 	ld	(x), a
      000346                        860 00103$:
                                    861 ;	lib/i2c.c: 100: I2C_DELAY();
      000346 4B 05            [ 1]  862 	push	#0x05
      000348 5F               [ 1]  863 	clrw	x
      000349 89               [ 2]  864 	pushw	x
      00034A 4B 00            [ 1]  865 	push	#0x00
      00034C CDr00r00         [ 4]  866 	call	_delay
      00034F 5B 04            [ 2]  867 	addw	sp, #4
                                    868 ;	lib/i2c.c: 101: ONE_SCL();
      000351 AE 50 07         [ 2]  869 	ldw	x, #0x5007
      000354 F6               [ 1]  870 	ld	a, (x)
      000355 A4 EF            [ 1]  871 	and	a, #0xef
      000357 F7               [ 1]  872 	ld	(x), a
      000358 AE 50 05         [ 2]  873 	ldw	x, #0x5005
      00035B F6               [ 1]  874 	ld	a, (x)
      00035C AA 10            [ 1]  875 	or	a, #0x10
      00035E F7               [ 1]  876 	ld	(x), a
                                    877 ;	lib/i2c.c: 102: I2C_DELAY();
      00035F 4B 05            [ 1]  878 	push	#0x05
      000361 5F               [ 1]  879 	clrw	x
      000362 89               [ 2]  880 	pushw	x
      000363 4B 00            [ 1]  881 	push	#0x00
      000365 CDr00r00         [ 4]  882 	call	_delay
      000368 5B 04            [ 2]  883 	addw	sp, #4
                                    884 ;	lib/i2c.c: 103: NULL_SCL();
      00036A AE 50 07         [ 2]  885 	ldw	x, #0x5007
      00036D F6               [ 1]  886 	ld	a, (x)
      00036E AA 10            [ 1]  887 	or	a, #0x10
      000370 F7               [ 1]  888 	ld	(x), a
      000371 AE 50 05         [ 2]  889 	ldw	x, #0x5005
      000374 F6               [ 1]  890 	ld	a, (x)
      000375 A4 EF            [ 1]  891 	and	a, #0xef
      000377 F7               [ 1]  892 	ld	(x), a
                                    893 ;	lib/i2c.c: 105: data = (data << 1);
      000378 08 05            [ 1]  894 	sll	(0x05, sp)
                                    895 ;	lib/i2c.c: 90: for(i = 0; i < 8; i++)
      00037A 0C 01            [ 1]  896 	inc	(0x01, sp)
      00037C 7B 01            [ 1]  897 	ld	a, (0x01, sp)
      00037E A1 08            [ 1]  898 	cp	a, #0x08
      000380 25 A0            [ 1]  899 	jrc	00108$
                                    900 ;	lib/i2c.c: 108: ONE_SDA();
      000382 AE 50 07         [ 2]  901 	ldw	x, #0x5007
      000385 F6               [ 1]  902 	ld	a, (x)
      000386 A4 DF            [ 1]  903 	and	a, #0xdf
      000388 F7               [ 1]  904 	ld	(x), a
      000389 AE 50 05         [ 2]  905 	ldw	x, #0x5005
      00038C F6               [ 1]  906 	ld	a, (x)
      00038D AA 20            [ 1]  907 	or	a, #0x20
      00038F F7               [ 1]  908 	ld	(x), a
                                    909 ;	lib/i2c.c: 109: I2C_DELAY();
      000390 4B 05            [ 1]  910 	push	#0x05
      000392 5F               [ 1]  911 	clrw	x
      000393 89               [ 2]  912 	pushw	x
      000394 4B 00            [ 1]  913 	push	#0x00
      000396 CDr00r00         [ 4]  914 	call	_delay
      000399 5B 04            [ 2]  915 	addw	sp, #4
                                    916 ;	lib/i2c.c: 110: ONE_SCL();
      00039B AE 50 07         [ 2]  917 	ldw	x, #0x5007
      00039E F6               [ 1]  918 	ld	a, (x)
      00039F A4 EF            [ 1]  919 	and	a, #0xef
      0003A1 F7               [ 1]  920 	ld	(x), a
      0003A2 AE 50 05         [ 2]  921 	ldw	x, #0x5005
      0003A5 F6               [ 1]  922 	ld	a, (x)
      0003A6 AA 10            [ 1]  923 	or	a, #0x10
      0003A8 F7               [ 1]  924 	ld	(x), a
                                    925 ;	lib/i2c.c: 111: I2C_DELAY();
      0003A9 4B 05            [ 1]  926 	push	#0x05
      0003AB 5F               [ 1]  927 	clrw	x
      0003AC 89               [ 2]  928 	pushw	x
      0003AD 4B 00            [ 1]  929 	push	#0x00
      0003AF CDr00r00         [ 4]  930 	call	_delay
      0003B2 5B 04            [ 2]  931 	addw	sp, #4
                                    932 ;	lib/i2c.c: 113: if((I2C_IDR & (1 << I2C_SDA)) == (1 << I2C_SDA))
      0003B4 AE 50 06         [ 2]  933 	ldw	x, #0x5006
      0003B7 F6               [ 1]  934 	ld	a, (x)
      0003B8 A4 20            [ 1]  935 	and	a, #0x20
      0003BA A1 20            [ 1]  936 	cp	a, #0x20
      0003BC 26 06            [ 1]  937 	jrne	00106$
                                    938 ;	lib/i2c.c: 115: ask = NACK;
      0003BE A6 01            [ 1]  939 	ld	a, #0x01
      0003C0 6B 02            [ 1]  940 	ld	(0x02, sp), a
      0003C2 20 02            [ 2]  941 	jra	00107$
      0003C4                        942 00106$:
                                    943 ;	lib/i2c.c: 119: ask = ACK;
      0003C4 0F 02            [ 1]  944 	clr	(0x02, sp)
      0003C6                        945 00107$:
                                    946 ;	lib/i2c.c: 122: NULL_SCL();
      0003C6 AE 50 07         [ 2]  947 	ldw	x, #0x5007
      0003C9 F6               [ 1]  948 	ld	a, (x)
      0003CA AA 10            [ 1]  949 	or	a, #0x10
      0003CC F7               [ 1]  950 	ld	(x), a
      0003CD AE 50 05         [ 2]  951 	ldw	x, #0x5005
      0003D0 F6               [ 1]  952 	ld	a, (x)
      0003D1 A4 EF            [ 1]  953 	and	a, #0xef
      0003D3 F7               [ 1]  954 	ld	(x), a
                                    955 ;	lib/i2c.c: 124: return ask;
      0003D4 7B 02            [ 1]  956 	ld	a, (0x02, sp)
      0003D6 5B 02            [ 2]  957 	addw	sp, #2
      0003D8 81               [ 4]  958 	ret
                                    959 ;	lib/i2c.c: 131: unsigned char i2c_read_byte(unsigned char ask)
                                    960 ;	-----------------------------------------
                                    961 ;	 function i2c_read_byte
                                    962 ;	-----------------------------------------
      0003D9                        963 _i2c_read_byte:
      0003D9 52 02            [ 2]  964 	sub	sp, #2
                                    965 ;	lib/i2c.c: 133: unsigned char byte = 0;
      0003DB 0F 01            [ 1]  966 	clr	(0x01, sp)
                                    967 ;	lib/i2c.c: 136: ONE_SDA();
      0003DD AE 50 07         [ 2]  968 	ldw	x, #0x5007
      0003E0 F6               [ 1]  969 	ld	a, (x)
      0003E1 A4 DF            [ 1]  970 	and	a, #0xdf
      0003E3 F7               [ 1]  971 	ld	(x), a
      0003E4 AE 50 05         [ 2]  972 	ldw	x, #0x5005
      0003E7 F6               [ 1]  973 	ld	a, (x)
      0003E8 AA 20            [ 1]  974 	or	a, #0x20
      0003EA F7               [ 1]  975 	ld	(x), a
                                    976 ;	lib/i2c.c: 138: for(i = 0; i < 8; i++)
      0003EB 0F 02            [ 1]  977 	clr	(0x02, sp)
      0003ED                        978 00107$:
                                    979 ;	lib/i2c.c: 140: byte = (byte << 1);
      0003ED 08 01            [ 1]  980 	sll	(0x01, sp)
                                    981 ;	lib/i2c.c: 141: ONE_SCL();
      0003EF AE 50 07         [ 2]  982 	ldw	x, #0x5007
      0003F2 F6               [ 1]  983 	ld	a, (x)
      0003F3 A4 EF            [ 1]  984 	and	a, #0xef
      0003F5 F7               [ 1]  985 	ld	(x), a
      0003F6 AE 50 05         [ 2]  986 	ldw	x, #0x5005
      0003F9 F6               [ 1]  987 	ld	a, (x)
      0003FA AA 10            [ 1]  988 	or	a, #0x10
      0003FC F7               [ 1]  989 	ld	(x), a
                                    990 ;	lib/i2c.c: 142: I2C_DELAY();
      0003FD 4B 05            [ 1]  991 	push	#0x05
      0003FF 5F               [ 1]  992 	clrw	x
      000400 89               [ 2]  993 	pushw	x
      000401 4B 00            [ 1]  994 	push	#0x00
      000403 CDr00r00         [ 4]  995 	call	_delay
      000406 5B 04            [ 2]  996 	addw	sp, #4
                                    997 ;	lib/i2c.c: 143: if((I2C_IDR & (1 << I2C_SDA)) == (1 << I2C_SDA)) byte |= 0x01;
      000408 AE 50 06         [ 2]  998 	ldw	x, #0x5006
      00040B F6               [ 1]  999 	ld	a, (x)
      00040C A4 20            [ 1] 1000 	and	a, #0x20
      00040E A1 20            [ 1] 1001 	cp	a, #0x20
      000410 26 06            [ 1] 1002 	jrne	00102$
      000412 7B 01            [ 1] 1003 	ld	a, (0x01, sp)
      000414 AA 01            [ 1] 1004 	or	a, #0x01
      000416 6B 01            [ 1] 1005 	ld	(0x01, sp), a
      000418                       1006 00102$:
                                   1007 ;	lib/i2c.c: 144: NULL_SCL();
      000418 AE 50 07         [ 2] 1008 	ldw	x, #0x5007
      00041B F6               [ 1] 1009 	ld	a, (x)
      00041C AA 10            [ 1] 1010 	or	a, #0x10
      00041E F7               [ 1] 1011 	ld	(x), a
      00041F AE 50 05         [ 2] 1012 	ldw	x, #0x5005
      000422 F6               [ 1] 1013 	ld	a, (x)
      000423 A4 EF            [ 1] 1014 	and	a, #0xef
      000425 F7               [ 1] 1015 	ld	(x), a
                                   1016 ;	lib/i2c.c: 145: I2C_DELAY();
      000426 4B 05            [ 1] 1017 	push	#0x05
      000428 5F               [ 1] 1018 	clrw	x
      000429 89               [ 2] 1019 	pushw	x
      00042A 4B 00            [ 1] 1020 	push	#0x00
      00042C CDr00r00         [ 4] 1021 	call	_delay
      00042F 5B 04            [ 2] 1022 	addw	sp, #4
                                   1023 ;	lib/i2c.c: 138: for(i = 0; i < 8; i++)
      000431 0C 02            [ 1] 1024 	inc	(0x02, sp)
      000433 7B 02            [ 1] 1025 	ld	a, (0x02, sp)
      000435 A1 08            [ 1] 1026 	cp	a, #0x08
      000437 25 B4            [ 1] 1027 	jrc	00107$
                                   1028 ;	lib/i2c.c: 136: ONE_SDA();
      000439 AE 50 07         [ 2] 1029 	ldw	x, #0x5007
      00043C F6               [ 1] 1030 	ld	a, (x)
                                   1031 ;	lib/i2c.c: 148: if(ask == ACK)
      00043D 0D 05            [ 1] 1032 	tnz	(0x05, sp)
      00043F 26 0F            [ 1] 1033 	jrne	00105$
                                   1034 ;	lib/i2c.c: 150: NULL_SDA();
      000441 AA 20            [ 1] 1035 	or	a, #0x20
      000443 AE 50 07         [ 2] 1036 	ldw	x, #0x5007
      000446 F7               [ 1] 1037 	ld	(x), a
      000447 AE 50 05         [ 2] 1038 	ldw	x, #0x5005
      00044A F6               [ 1] 1039 	ld	a, (x)
      00044B A4 DF            [ 1] 1040 	and	a, #0xdf
      00044D F7               [ 1] 1041 	ld	(x), a
      00044E 20 0D            [ 2] 1042 	jra	00106$
      000450                       1043 00105$:
                                   1044 ;	lib/i2c.c: 154: ONE_SDA();
      000450 A4 DF            [ 1] 1045 	and	a, #0xdf
      000452 AE 50 07         [ 2] 1046 	ldw	x, #0x5007
      000455 F7               [ 1] 1047 	ld	(x), a
      000456 AE 50 05         [ 2] 1048 	ldw	x, #0x5005
      000459 F6               [ 1] 1049 	ld	a, (x)
      00045A AA 20            [ 1] 1050 	or	a, #0x20
      00045C F7               [ 1] 1051 	ld	(x), a
      00045D                       1052 00106$:
                                   1053 ;	lib/i2c.c: 156: I2C_DELAY();
      00045D 4B 05            [ 1] 1054 	push	#0x05
      00045F 5F               [ 1] 1055 	clrw	x
      000460 89               [ 2] 1056 	pushw	x
      000461 4B 00            [ 1] 1057 	push	#0x00
      000463 CDr00r00         [ 4] 1058 	call	_delay
      000466 5B 04            [ 2] 1059 	addw	sp, #4
                                   1060 ;	lib/i2c.c: 157: ONE_SCL();
      000468 AE 50 07         [ 2] 1061 	ldw	x, #0x5007
      00046B F6               [ 1] 1062 	ld	a, (x)
      00046C A4 EF            [ 1] 1063 	and	a, #0xef
      00046E F7               [ 1] 1064 	ld	(x), a
      00046F AE 50 05         [ 2] 1065 	ldw	x, #0x5005
      000472 F6               [ 1] 1066 	ld	a, (x)
      000473 AA 10            [ 1] 1067 	or	a, #0x10
      000475 F7               [ 1] 1068 	ld	(x), a
                                   1069 ;	lib/i2c.c: 158: I2C_DELAY();
      000476 4B 05            [ 1] 1070 	push	#0x05
      000478 5F               [ 1] 1071 	clrw	x
      000479 89               [ 2] 1072 	pushw	x
      00047A 4B 00            [ 1] 1073 	push	#0x00
      00047C CDr00r00         [ 4] 1074 	call	_delay
      00047F 5B 04            [ 2] 1075 	addw	sp, #4
                                   1076 ;	lib/i2c.c: 159: NULL_SCL();
      000481 AE 50 07         [ 2] 1077 	ldw	x, #0x5007
      000484 F6               [ 1] 1078 	ld	a, (x)
      000485 AA 10            [ 1] 1079 	or	a, #0x10
      000487 F7               [ 1] 1080 	ld	(x), a
      000488 AE 50 05         [ 2] 1081 	ldw	x, #0x5005
      00048B F6               [ 1] 1082 	ld	a, (x)
      00048C A4 EF            [ 1] 1083 	and	a, #0xef
      00048E F7               [ 1] 1084 	ld	(x), a
                                   1085 ;	lib/i2c.c: 160: I2C_DELAY();
      00048F 4B 05            [ 1] 1086 	push	#0x05
      000491 5F               [ 1] 1087 	clrw	x
      000492 89               [ 2] 1088 	pushw	x
      000493 4B 00            [ 1] 1089 	push	#0x00
      000495 CDr00r00         [ 4] 1090 	call	_delay
      000498 5B 04            [ 2] 1091 	addw	sp, #4
                                   1092 ;	lib/i2c.c: 161: ONE_SDA();
      00049A AE 50 07         [ 2] 1093 	ldw	x, #0x5007
      00049D F6               [ 1] 1094 	ld	a, (x)
      00049E A4 DF            [ 1] 1095 	and	a, #0xdf
      0004A0 F7               [ 1] 1096 	ld	(x), a
      0004A1 AE 50 05         [ 2] 1097 	ldw	x, #0x5005
      0004A4 F6               [ 1] 1098 	ld	a, (x)
      0004A5 AA 20            [ 1] 1099 	or	a, #0x20
      0004A7 F7               [ 1] 1100 	ld	(x), a
                                   1101 ;	lib/i2c.c: 163: return byte;
      0004A8 7B 01            [ 1] 1102 	ld	a, (0x01, sp)
      0004AA 5B 02            [ 2] 1103 	addw	sp, #2
      0004AC 81               [ 4] 1104 	ret
                                   1105 ;	lib/rtc.c: 3: unsigned char RTC_ConvertFromDec(unsigned char c){
                                   1106 ;	-----------------------------------------
                                   1107 ;	 function RTC_ConvertFromDec
                                   1108 ;	-----------------------------------------
      0004AD                       1109 _RTC_ConvertFromDec:
      0004AD 88               [ 1] 1110 	push	a
                                   1111 ;	lib/rtc.c: 4: unsigned char ch = ((c>>4)*10+(0b00001111&c));
      0004AE 7B 04            [ 1] 1112 	ld	a, (0x04, sp)
      0004B0 4E               [ 1] 1113 	swap	a
      0004B1 A4 0F            [ 1] 1114 	and	a, #0x0f
      0004B3 41               [ 1] 1115 	exg	a, xl
      0004B4 A6 0A            [ 1] 1116 	ld	a, #0x0a
      0004B6 41               [ 1] 1117 	exg	a, xl
      0004B7 42               [ 4] 1118 	mul	x, a
      0004B8 7B 04            [ 1] 1119 	ld	a, (0x04, sp)
      0004BA A4 0F            [ 1] 1120 	and	a, #0x0f
      0004BC 6B 01            [ 1] 1121 	ld	(0x01, sp), a
      0004BE 9F               [ 1] 1122 	ld	a, xl
      0004BF 1B 01            [ 1] 1123 	add	a, (0x01, sp)
                                   1124 ;	lib/rtc.c: 5: return ch;
      0004C1 5B 01            [ 2] 1125 	addw	sp, #1
      0004C3 81               [ 4] 1126 	ret
                                   1127 ;	lib/rtc.c: 8: unsigned char RTC_ConvertFromBinDec(unsigned char c){
                                   1128 ;	-----------------------------------------
                                   1129 ;	 function RTC_ConvertFromBinDec
                                   1130 ;	-----------------------------------------
      0004C4                       1131 _RTC_ConvertFromBinDec:
      0004C4 88               [ 1] 1132 	push	a
                                   1133 ;	lib/rtc.c: 9: unsigned char ch = ((c/10)<<4)|(c%10);
      0004C5 5F               [ 1] 1134 	clrw	x
      0004C6 7B 04            [ 1] 1135 	ld	a, (0x04, sp)
      0004C8 97               [ 1] 1136 	ld	xl, a
      0004C9 A6 0A            [ 1] 1137 	ld	a, #0x0a
      0004CB 62               [ 2] 1138 	div	x, a
      0004CC 9F               [ 1] 1139 	ld	a, xl
      0004CD 4E               [ 1] 1140 	swap	a
      0004CE A4 F0            [ 1] 1141 	and	a, #0xf0
      0004D0 6B 01            [ 1] 1142 	ld	(0x01, sp), a
      0004D2 5F               [ 1] 1143 	clrw	x
      0004D3 7B 04            [ 1] 1144 	ld	a, (0x04, sp)
      0004D5 97               [ 1] 1145 	ld	xl, a
      0004D6 A6 0A            [ 1] 1146 	ld	a, #0x0a
      0004D8 62               [ 2] 1147 	div	x, a
      0004D9 1A 01            [ 1] 1148 	or	a, (0x01, sp)
                                   1149 ;	lib/rtc.c: 10: return ch;
      0004DB 5B 01            [ 2] 1150 	addw	sp, #1
      0004DD 81               [ 4] 1151 	ret
                                   1152 ;	lib/rtc.c: 18: void RTC_Read(){
                                   1153 ;	-----------------------------------------
                                   1154 ;	 function RTC_Read
                                   1155 ;	-----------------------------------------
      0004DE                       1156 _RTC_Read:
                                   1157 ;	lib/rtc.c: 21: i2c_start();
      0004DE CDr02r67         [ 4] 1158 	call	_i2c_start
                                   1159 ;	lib/rtc.c: 22: i2c_send_byte(0xD0);
      0004E1 4B D0            [ 1] 1160 	push	#0xd0
      0004E3 CDr03r1E         [ 4] 1161 	call	_i2c_send_byte
      0004E6 84               [ 1] 1162 	pop	a
                                   1163 ;	lib/rtc.c: 23: i2c_send_byte(0x00);
      0004E7 4B 00            [ 1] 1164 	push	#0x00
      0004E9 CDr03r1E         [ 4] 1165 	call	_i2c_send_byte
      0004EC 84               [ 1] 1166 	pop	a
                                   1167 ;	lib/rtc.c: 24: i2c_restart();
      0004ED CDr02r9A         [ 4] 1168 	call	_i2c_restart
                                   1169 ;	lib/rtc.c: 25: i2c_send_byte(0xD1);
      0004F0 4B D1            [ 1] 1170 	push	#0xd1
      0004F2 CDr03r1E         [ 4] 1171 	call	_i2c_send_byte
      0004F5 84               [ 1] 1172 	pop	a
                                   1173 ;	lib/rtc.c: 26: sec		= i2c_read_byte(0);
      0004F6 4B 00            [ 1] 1174 	push	#0x00
      0004F8 CDr03rD9         [ 4] 1175 	call	_i2c_read_byte
      0004FB 5B 01            [ 2] 1176 	addw	sp, #1
      0004FD C7u00u00         [ 1] 1177 	ld	_sec+0, a
                                   1178 ;	lib/rtc.c: 27: min		= i2c_read_byte(0);
      000500 4B 00            [ 1] 1179 	push	#0x00
      000502 CDr03rD9         [ 4] 1180 	call	_i2c_read_byte
      000505 5B 01            [ 2] 1181 	addw	sp, #1
      000507 C7u00u01         [ 1] 1182 	ld	_min+0, a
                                   1183 ;	lib/rtc.c: 28: hour	= i2c_read_byte(0);
      00050A 4B 00            [ 1] 1184 	push	#0x00
      00050C CDr03rD9         [ 4] 1185 	call	_i2c_read_byte
      00050F 5B 01            [ 2] 1186 	addw	sp, #1
      000511 C7u00u02         [ 1] 1187 	ld	_hour+0, a
                                   1188 ;	lib/rtc.c: 29: day		= i2c_read_byte(0);
      000514 4B 00            [ 1] 1189 	push	#0x00
      000516 CDr03rD9         [ 4] 1190 	call	_i2c_read_byte
      000519 5B 01            [ 2] 1191 	addw	sp, #1
      00051B C7u00u03         [ 1] 1192 	ld	_day+0, a
                                   1193 ;	lib/rtc.c: 30: date	= i2c_read_byte(0);
      00051E 4B 00            [ 1] 1194 	push	#0x00
      000520 CDr03rD9         [ 4] 1195 	call	_i2c_read_byte
      000523 5B 01            [ 2] 1196 	addw	sp, #1
      000525 C7u00u04         [ 1] 1197 	ld	_date+0, a
                                   1198 ;	lib/rtc.c: 31: month	= i2c_read_byte(0);
      000528 4B 00            [ 1] 1199 	push	#0x00
      00052A CDr03rD9         [ 4] 1200 	call	_i2c_read_byte
      00052D 5B 01            [ 2] 1201 	addw	sp, #1
      00052F C7u00u05         [ 1] 1202 	ld	_month+0, a
                                   1203 ;	lib/rtc.c: 32: year	= i2c_read_byte(1);
      000532 4B 01            [ 1] 1204 	push	#0x01
      000534 CDr03rD9         [ 4] 1205 	call	_i2c_read_byte
      000537 5B 01            [ 2] 1206 	addw	sp, #1
      000539 C7u00u06         [ 1] 1207 	ld	_year+0, a
                                   1208 ;	lib/rtc.c: 33: i2c_stop();
      00053C CDr01rB7         [ 4] 1209 	call	_i2c_stop
                                   1210 ;	lib/rtc.c: 35: sec		= RTC_ConvertFromDec(sec);
      00053F 3Bu00u00         [ 1] 1211 	push	_sec+0
      000542 CDr04rAD         [ 4] 1212 	call	_RTC_ConvertFromDec
      000545 5B 01            [ 2] 1213 	addw	sp, #1
      000547 C7u00u00         [ 1] 1214 	ld	_sec+0, a
                                   1215 ;	lib/rtc.c: 36: min		= RTC_ConvertFromDec(min);
      00054A 3Bu00u01         [ 1] 1216 	push	_min+0
      00054D CDr04rAD         [ 4] 1217 	call	_RTC_ConvertFromDec
      000550 5B 01            [ 2] 1218 	addw	sp, #1
      000552 C7u00u01         [ 1] 1219 	ld	_min+0, a
                                   1220 ;	lib/rtc.c: 37: hour	= RTC_ConvertFromDec(hour);
      000555 3Bu00u02         [ 1] 1221 	push	_hour+0
      000558 CDr04rAD         [ 4] 1222 	call	_RTC_ConvertFromDec
      00055B 5B 01            [ 2] 1223 	addw	sp, #1
      00055D C7u00u02         [ 1] 1224 	ld	_hour+0, a
                                   1225 ;	lib/rtc.c: 38: day		= RTC_ConvertFromDec(day);
      000560 3Bu00u03         [ 1] 1226 	push	_day+0
      000563 CDr04rAD         [ 4] 1227 	call	_RTC_ConvertFromDec
      000566 5B 01            [ 2] 1228 	addw	sp, #1
      000568 C7u00u03         [ 1] 1229 	ld	_day+0, a
                                   1230 ;	lib/rtc.c: 39: date	= RTC_ConvertFromDec(date);
      00056B 3Bu00u04         [ 1] 1231 	push	_date+0
      00056E CDr04rAD         [ 4] 1232 	call	_RTC_ConvertFromDec
      000571 5B 01            [ 2] 1233 	addw	sp, #1
      000573 C7u00u04         [ 1] 1234 	ld	_date+0, a
                                   1235 ;	lib/rtc.c: 40: month	= RTC_ConvertFromDec(month);
      000576 3Bu00u05         [ 1] 1236 	push	_month+0
      000579 CDr04rAD         [ 4] 1237 	call	_RTC_ConvertFromDec
      00057C 5B 01            [ 2] 1238 	addw	sp, #1
      00057E C7u00u05         [ 1] 1239 	ld	_month+0, a
                                   1240 ;	lib/rtc.c: 41: year	= RTC_ConvertFromDec(year);
      000581 3Bu00u06         [ 1] 1241 	push	_year+0
      000584 CDr04rAD         [ 4] 1242 	call	_RTC_ConvertFromDec
      000587 5B 01            [ 2] 1243 	addw	sp, #1
      000589 C7u00u06         [ 1] 1244 	ld	_year+0, a
      00058C 81               [ 4] 1245 	ret
                                   1246 ;	lib/rtc.c: 45: void RTC_Set(unsigned char sec, unsigned char min, unsigned char hour, unsigned char day, unsigned char date, unsigned char month, unsigned char year){
                                   1247 ;	-----------------------------------------
                                   1248 ;	 function RTC_Set
                                   1249 ;	-----------------------------------------
      00058D                       1250 _RTC_Set:
      00058D 52 07            [ 2] 1251 	sub	sp, #7
                                   1252 ;	lib/rtc.c: 46: sec		= RTC_ConvertFromBinDec(sec);
      00058F 7B 0A            [ 1] 1253 	ld	a, (0x0a, sp)
      000591 88               [ 1] 1254 	push	a
      000592 CDr04rC4         [ 4] 1255 	call	_RTC_ConvertFromBinDec
      000595 5B 01            [ 2] 1256 	addw	sp, #1
      000597 6B 04            [ 1] 1257 	ld	(0x04, sp), a
                                   1258 ;	lib/rtc.c: 47: min		= RTC_ConvertFromBinDec(min);
      000599 7B 0B            [ 1] 1259 	ld	a, (0x0b, sp)
      00059B 88               [ 1] 1260 	push	a
      00059C CDr04rC4         [ 4] 1261 	call	_RTC_ConvertFromBinDec
      00059F 5B 01            [ 2] 1262 	addw	sp, #1
      0005A1 6B 05            [ 1] 1263 	ld	(0x05, sp), a
                                   1264 ;	lib/rtc.c: 48: hour	= RTC_ConvertFromBinDec(hour);
      0005A3 7B 0C            [ 1] 1265 	ld	a, (0x0c, sp)
      0005A5 88               [ 1] 1266 	push	a
      0005A6 CDr04rC4         [ 4] 1267 	call	_RTC_ConvertFromBinDec
      0005A9 5B 01            [ 2] 1268 	addw	sp, #1
      0005AB 6B 06            [ 1] 1269 	ld	(0x06, sp), a
                                   1270 ;	lib/rtc.c: 49: day		= RTC_ConvertFromBinDec(day);
      0005AD 7B 0D            [ 1] 1271 	ld	a, (0x0d, sp)
      0005AF 88               [ 1] 1272 	push	a
      0005B0 CDr04rC4         [ 4] 1273 	call	_RTC_ConvertFromBinDec
      0005B3 5B 01            [ 2] 1274 	addw	sp, #1
      0005B5 6B 07            [ 1] 1275 	ld	(0x07, sp), a
                                   1276 ;	lib/rtc.c: 50: date	= RTC_ConvertFromBinDec(date);
      0005B7 7B 0E            [ 1] 1277 	ld	a, (0x0e, sp)
      0005B9 88               [ 1] 1278 	push	a
      0005BA CDr04rC4         [ 4] 1279 	call	_RTC_ConvertFromBinDec
      0005BD 5B 01            [ 2] 1280 	addw	sp, #1
      0005BF 6B 03            [ 1] 1281 	ld	(0x03, sp), a
                                   1282 ;	lib/rtc.c: 51: month	= RTC_ConvertFromBinDec(month);
      0005C1 7B 0F            [ 1] 1283 	ld	a, (0x0f, sp)
      0005C3 88               [ 1] 1284 	push	a
      0005C4 CDr04rC4         [ 4] 1285 	call	_RTC_ConvertFromBinDec
      0005C7 5B 01            [ 2] 1286 	addw	sp, #1
      0005C9 6B 02            [ 1] 1287 	ld	(0x02, sp), a
                                   1288 ;	lib/rtc.c: 52: year	= RTC_ConvertFromBinDec(year);
      0005CB 7B 10            [ 1] 1289 	ld	a, (0x10, sp)
      0005CD 88               [ 1] 1290 	push	a
      0005CE CDr04rC4         [ 4] 1291 	call	_RTC_ConvertFromBinDec
      0005D1 5B 01            [ 2] 1292 	addw	sp, #1
      0005D3 6B 01            [ 1] 1293 	ld	(0x01, sp), a
                                   1294 ;	lib/rtc.c: 54: i2c_start();
      0005D5 CDr02r67         [ 4] 1295 	call	_i2c_start
                                   1296 ;	lib/rtc.c: 55: i2c_send_byte(0xD0);
      0005D8 4B D0            [ 1] 1297 	push	#0xd0
      0005DA CDr03r1E         [ 4] 1298 	call	_i2c_send_byte
      0005DD 84               [ 1] 1299 	pop	a
                                   1300 ;	lib/rtc.c: 56: i2c_send_byte(0x00);
      0005DE 4B 00            [ 1] 1301 	push	#0x00
      0005E0 CDr03r1E         [ 4] 1302 	call	_i2c_send_byte
      0005E3 84               [ 1] 1303 	pop	a
                                   1304 ;	lib/rtc.c: 58: i2c_send_byte(sec);
      0005E4 7B 04            [ 1] 1305 	ld	a, (0x04, sp)
      0005E6 88               [ 1] 1306 	push	a
      0005E7 CDr03r1E         [ 4] 1307 	call	_i2c_send_byte
      0005EA 84               [ 1] 1308 	pop	a
                                   1309 ;	lib/rtc.c: 59: i2c_send_byte(min);
      0005EB 7B 05            [ 1] 1310 	ld	a, (0x05, sp)
      0005ED 88               [ 1] 1311 	push	a
      0005EE CDr03r1E         [ 4] 1312 	call	_i2c_send_byte
      0005F1 84               [ 1] 1313 	pop	a
                                   1314 ;	lib/rtc.c: 60: i2c_send_byte(hour);
      0005F2 7B 06            [ 1] 1315 	ld	a, (0x06, sp)
      0005F4 88               [ 1] 1316 	push	a
      0005F5 CDr03r1E         [ 4] 1317 	call	_i2c_send_byte
      0005F8 84               [ 1] 1318 	pop	a
                                   1319 ;	lib/rtc.c: 61: i2c_send_byte(day);
      0005F9 7B 07            [ 1] 1320 	ld	a, (0x07, sp)
      0005FB 88               [ 1] 1321 	push	a
      0005FC CDr03r1E         [ 4] 1322 	call	_i2c_send_byte
      0005FF 84               [ 1] 1323 	pop	a
                                   1324 ;	lib/rtc.c: 62: i2c_send_byte(date);
      000600 7B 03            [ 1] 1325 	ld	a, (0x03, sp)
      000602 88               [ 1] 1326 	push	a
      000603 CDr03r1E         [ 4] 1327 	call	_i2c_send_byte
      000606 84               [ 1] 1328 	pop	a
                                   1329 ;	lib/rtc.c: 63: i2c_send_byte(month);
      000607 7B 02            [ 1] 1330 	ld	a, (0x02, sp)
      000609 88               [ 1] 1331 	push	a
      00060A CDr03r1E         [ 4] 1332 	call	_i2c_send_byte
      00060D 84               [ 1] 1333 	pop	a
                                   1334 ;	lib/rtc.c: 64: i2c_send_byte(year);
      00060E 7B 01            [ 1] 1335 	ld	a, (0x01, sp)
      000610 88               [ 1] 1336 	push	a
      000611 CDr03r1E         [ 4] 1337 	call	_i2c_send_byte
      000614 84               [ 1] 1338 	pop	a
                                   1339 ;	lib/rtc.c: 65: i2c_stop();
      000615 CDr01rB7         [ 4] 1340 	call	_i2c_stop
      000618 5B 07            [ 2] 1341 	addw	sp, #7
      00061A 81               [ 4] 1342 	ret
                                   1343 ;	lib/rtc.c: 81: void conSec(long secin){
                                   1344 ;	-----------------------------------------
                                   1345 ;	 function conSec
                                   1346 ;	-----------------------------------------
      00061B                       1347 _conSec:
      00061B 52 10            [ 2] 1348 	sub	sp, #16
                                   1349 ;	lib/rtc.c: 87: con_day = secin/86400;
      00061D 4B 80            [ 1] 1350 	push	#0x80
      00061F 4B 51            [ 1] 1351 	push	#0x51
      000621 4B 01            [ 1] 1352 	push	#0x01
      000623 4B 00            [ 1] 1353 	push	#0x00
      000625 1E 19            [ 2] 1354 	ldw	x, (0x19, sp)
      000627 89               [ 2] 1355 	pushw	x
      000628 1E 19            [ 2] 1356 	ldw	x, (0x19, sp)
      00062A 89               [ 2] 1357 	pushw	x
      00062B CDr00r00         [ 4] 1358 	call	__divslong
      00062E 5B 08            [ 2] 1359 	addw	sp, #8
      000630 CFu00u13         [ 2] 1360 	ldw	_con_day+2, x
      000633 90 CFu00u11      [ 2] 1361 	ldw	_con_day+0, y
                                   1362 ;	lib/rtc.c: 88: secin = secin-(con_day*86400);
      000637 3Bu00u14         [ 1] 1363 	push	_con_day+3
      00063A 3Bu00u13         [ 1] 1364 	push	_con_day+2
      00063D 3Bu00u12         [ 1] 1365 	push	_con_day+1
      000640 3Bu00u11         [ 1] 1366 	push	_con_day+0
      000643 4B 80            [ 1] 1367 	push	#0x80
      000645 4B 51            [ 1] 1368 	push	#0x51
      000647 4B 01            [ 1] 1369 	push	#0x01
      000649 4B 00            [ 1] 1370 	push	#0x00
      00064B CDr00r00         [ 4] 1371 	call	__mullong
      00064E 5B 08            [ 2] 1372 	addw	sp, #8
      000650 1F 07            [ 2] 1373 	ldw	(0x07, sp), x
      000652 17 05            [ 2] 1374 	ldw	(0x05, sp), y
      000654 16 15            [ 2] 1375 	ldw	y, (0x15, sp)
      000656 1E 13            [ 2] 1376 	ldw	x, (0x13, sp)
      000658 72 F2 07         [ 2] 1377 	subw	y, (0x07, sp)
      00065B 9F               [ 1] 1378 	ld	a, xl
      00065C 12 06            [ 1] 1379 	sbc	a, (0x06, sp)
      00065E 02               [ 1] 1380 	rlwa	x
      00065F 12 05            [ 1] 1381 	sbc	a, (0x05, sp)
      000661 95               [ 1] 1382 	ld	xh, a
      000662 17 15            [ 2] 1383 	ldw	(0x15, sp), y
      000664 1F 13            [ 2] 1384 	ldw	(0x13, sp), x
                                   1385 ;	lib/rtc.c: 90: con_hour = (secin/3600);
      000666 4B 10            [ 1] 1386 	push	#0x10
      000668 4B 0E            [ 1] 1387 	push	#0x0e
      00066A 5F               [ 1] 1388 	clrw	x
      00066B 89               [ 2] 1389 	pushw	x
      00066C 1E 19            [ 2] 1390 	ldw	x, (0x19, sp)
      00066E 89               [ 2] 1391 	pushw	x
      00066F 1E 19            [ 2] 1392 	ldw	x, (0x19, sp)
      000671 89               [ 2] 1393 	pushw	x
      000672 CDr00r00         [ 4] 1394 	call	__divslong
      000675 5B 08            [ 2] 1395 	addw	sp, #8
      000677 CFu00u17         [ 2] 1396 	ldw	_con_hour+2, x
      00067A 90 CFu00u15      [ 2] 1397 	ldw	_con_hour+0, y
                                   1398 ;	lib/rtc.c: 91: con_min	 = ((secin-(3600*con_hour))/60);
      00067E 3Bu00u18         [ 1] 1399 	push	_con_hour+3
      000681 3Bu00u17         [ 1] 1400 	push	_con_hour+2
      000684 3Bu00u16         [ 1] 1401 	push	_con_hour+1
      000687 3Bu00u15         [ 1] 1402 	push	_con_hour+0
      00068A 4B 10            [ 1] 1403 	push	#0x10
      00068C 4B 0E            [ 1] 1404 	push	#0x0e
      00068E 5F               [ 1] 1405 	clrw	x
      00068F 89               [ 2] 1406 	pushw	x
      000690 CDr00r00         [ 4] 1407 	call	__mullong
      000693 5B 08            [ 2] 1408 	addw	sp, #8
      000695 1F 03            [ 2] 1409 	ldw	(0x03, sp), x
      000697 17 01            [ 2] 1410 	ldw	(0x01, sp), y
      000699 16 15            [ 2] 1411 	ldw	y, (0x15, sp)
      00069B 17 0F            [ 2] 1412 	ldw	(0x0f, sp), y
      00069D 16 13            [ 2] 1413 	ldw	y, (0x13, sp)
      00069F 17 0D            [ 2] 1414 	ldw	(0x0d, sp), y
      0006A1 16 0F            [ 2] 1415 	ldw	y, (0x0f, sp)
      0006A3 72 F2 03         [ 2] 1416 	subw	y, (0x03, sp)
      0006A6 7B 0E            [ 1] 1417 	ld	a, (0x0e, sp)
      0006A8 12 02            [ 1] 1418 	sbc	a, (0x02, sp)
      0006AA 97               [ 1] 1419 	ld	xl, a
      0006AB 7B 0D            [ 1] 1420 	ld	a, (0x0d, sp)
      0006AD 12 01            [ 1] 1421 	sbc	a, (0x01, sp)
      0006AF 95               [ 1] 1422 	ld	xh, a
      0006B0 4B 3C            [ 1] 1423 	push	#0x3c
      0006B2 4B 00            [ 1] 1424 	push	#0x00
      0006B4 4B 00            [ 1] 1425 	push	#0x00
      0006B6 4B 00            [ 1] 1426 	push	#0x00
      0006B8 90 89            [ 2] 1427 	pushw	y
      0006BA 89               [ 2] 1428 	pushw	x
      0006BB CDr00r00         [ 4] 1429 	call	__divulong
      0006BE 5B 08            [ 2] 1430 	addw	sp, #8
      0006C0 CFu00u1B         [ 2] 1431 	ldw	_con_min+2, x
      0006C3 90 CFu00u19      [ 2] 1432 	ldw	_con_min+0, y
                                   1433 ;	lib/rtc.c: 92: con_sec	 = (secin-(((con_hour*60)*60)+(con_min*60)));
      0006C7 3Bu00u1C         [ 1] 1434 	push	_con_min+3
      0006CA 3Bu00u1B         [ 1] 1435 	push	_con_min+2
      0006CD 3Bu00u1A         [ 1] 1436 	push	_con_min+1
      0006D0 3Bu00u19         [ 1] 1437 	push	_con_min+0
      0006D3 4B 3C            [ 1] 1438 	push	#0x3c
      0006D5 5F               [ 1] 1439 	clrw	x
      0006D6 89               [ 2] 1440 	pushw	x
      0006D7 4B 00            [ 1] 1441 	push	#0x00
      0006D9 CDr00r00         [ 4] 1442 	call	__mullong
      0006DC 5B 08            [ 2] 1443 	addw	sp, #8
      0006DE 51               [ 1] 1444 	exgw	x, y
      0006DF 72 F9 03         [ 2] 1445 	addw	y, (0x03, sp)
      0006E2 9F               [ 1] 1446 	ld	a, xl
      0006E3 19 02            [ 1] 1447 	adc	a, (0x02, sp)
      0006E5 6B 0A            [ 1] 1448 	ld	(0x0a, sp), a
      0006E7 9E               [ 1] 1449 	ld	a, xh
      0006E8 19 01            [ 1] 1450 	adc	a, (0x01, sp)
      0006EA 95               [ 1] 1451 	ld	xh, a
      0006EB 7B 10            [ 1] 1452 	ld	a, (0x10, sp)
      0006ED 90 89            [ 2] 1453 	pushw	y
      0006EF 10 02            [ 1] 1454 	sub	a, (#2, sp)
      0006F1 90 85            [ 2] 1455 	popw	y
      0006F3 90 97            [ 1] 1456 	ld	yl, a
      0006F5 7B 0F            [ 1] 1457 	ld	a, (0x0f, sp)
      0006F7 90 89            [ 2] 1458 	pushw	y
      0006F9 12 01            [ 1] 1459 	sbc	a, (#1, sp)
      0006FB 90 85            [ 2] 1460 	popw	y
      0006FD 90 95            [ 1] 1461 	ld	yh, a
      0006FF 7B 0E            [ 1] 1462 	ld	a, (0x0e, sp)
      000701 12 0A            [ 1] 1463 	sbc	a, (0x0a, sp)
      000703 97               [ 1] 1464 	ld	xl, a
      000704 7B 0D            [ 1] 1465 	ld	a, (0x0d, sp)
      000706 89               [ 2] 1466 	pushw	x
      000707 12 01            [ 1] 1467 	sbc	a, (#1, sp)
      000709 85               [ 2] 1468 	popw	x
      00070A 95               [ 1] 1469 	ld	xh, a
      00070B 90 CFu00u1F      [ 2] 1470 	ldw	_con_sec+2, y
      00070F CFu00u1D         [ 2] 1471 	ldw	_con_sec+0, x
      000712 5B 10            [ 2] 1472 	addw	sp, #16
      000714 81               [ 4] 1473 	ret
                                   1474 ;	lib/rtc.c: 95: unsigned long transTime(unsigned long d, unsigned long h, unsigned long m, unsigned long s){ //d, h, m, s
                                   1475 ;	-----------------------------------------
                                   1476 ;	 function transTime
                                   1477 ;	-----------------------------------------
      000715                       1478 _transTime:
      000715 52 04            [ 2] 1479 	sub	sp, #4
                                   1480 ;	lib/rtc.c: 96: return ((d*86400)+(((h*60)+m)*60+s));
      000717 1E 09            [ 2] 1481 	ldw	x, (0x09, sp)
      000719 89               [ 2] 1482 	pushw	x
      00071A 1E 09            [ 2] 1483 	ldw	x, (0x09, sp)
      00071C 89               [ 2] 1484 	pushw	x
      00071D 4B 80            [ 1] 1485 	push	#0x80
      00071F 4B 51            [ 1] 1486 	push	#0x51
      000721 4B 01            [ 1] 1487 	push	#0x01
      000723 4B 00            [ 1] 1488 	push	#0x00
      000725 CDr00r00         [ 4] 1489 	call	__mullong
      000728 5B 08            [ 2] 1490 	addw	sp, #8
      00072A 1F 03            [ 2] 1491 	ldw	(0x03, sp), x
      00072C 17 01            [ 2] 1492 	ldw	(0x01, sp), y
      00072E 1E 0D            [ 2] 1493 	ldw	x, (0x0d, sp)
      000730 89               [ 2] 1494 	pushw	x
      000731 1E 0D            [ 2] 1495 	ldw	x, (0x0d, sp)
      000733 89               [ 2] 1496 	pushw	x
      000734 4B 3C            [ 1] 1497 	push	#0x3c
      000736 5F               [ 1] 1498 	clrw	x
      000737 89               [ 2] 1499 	pushw	x
      000738 4B 00            [ 1] 1500 	push	#0x00
      00073A CDr00r00         [ 4] 1501 	call	__mullong
      00073D 5B 08            [ 2] 1502 	addw	sp, #8
      00073F 51               [ 1] 1503 	exgw	x, y
      000740 72 F9 11         [ 2] 1504 	addw	y, (0x11, sp)
      000743 9F               [ 1] 1505 	ld	a, xl
      000744 19 10            [ 1] 1506 	adc	a, (0x10, sp)
      000746 02               [ 1] 1507 	rlwa	x
      000747 19 0F            [ 1] 1508 	adc	a, (0x0f, sp)
      000749 95               [ 1] 1509 	ld	xh, a
      00074A 90 89            [ 2] 1510 	pushw	y
      00074C 89               [ 2] 1511 	pushw	x
      00074D 4B 3C            [ 1] 1512 	push	#0x3c
      00074F 5F               [ 1] 1513 	clrw	x
      000750 89               [ 2] 1514 	pushw	x
      000751 4B 00            [ 1] 1515 	push	#0x00
      000753 CDr00r00         [ 4] 1516 	call	__mullong
      000756 5B 08            [ 2] 1517 	addw	sp, #8
      000758 51               [ 1] 1518 	exgw	x, y
      000759 72 F9 15         [ 2] 1519 	addw	y, (0x15, sp)
      00075C 9F               [ 1] 1520 	ld	a, xl
      00075D 19 14            [ 1] 1521 	adc	a, (0x14, sp)
      00075F 02               [ 1] 1522 	rlwa	x
      000760 19 13            [ 1] 1523 	adc	a, (0x13, sp)
      000762 95               [ 1] 1524 	ld	xh, a
      000763 72 F9 03         [ 2] 1525 	addw	y, (0x03, sp)
      000766 9F               [ 1] 1526 	ld	a, xl
      000767 19 02            [ 1] 1527 	adc	a, (0x02, sp)
      000769 02               [ 1] 1528 	rlwa	x
      00076A 19 01            [ 1] 1529 	adc	a, (0x01, sp)
      00076C 95               [ 1] 1530 	ld	xh, a
      00076D 51               [ 1] 1531 	exgw	x, y
      00076E 5B 04            [ 2] 1532 	addw	sp, #4
      000770 81               [ 4] 1533 	ret
                                   1534 ;	lib/eeprom.c: 3: void EEPROM_UNLOCK(void){
                                   1535 ;	-----------------------------------------
                                   1536 ;	 function EEPROM_UNLOCK
                                   1537 ;	-----------------------------------------
      000771                       1538 _EEPROM_UNLOCK:
                                   1539 ;	lib/eeprom.c: 5: FLASH_DUKR = 0xAE; // unlock EEPROM
      000771 35 AE 50 64      [ 1] 1540 	mov	0x5064+0, #0xae
                                   1541 ;	lib/eeprom.c: 6: FLASH_DUKR = 0x56;
      000775 35 56 50 64      [ 1] 1542 	mov	0x5064+0, #0x56
                                   1543 ;	lib/eeprom.c: 8: while (!(FLASH_IAPSR & (1<<3))); // check protection off
      000779                       1544 00101$:
      000779 AE 50 5F         [ 2] 1545 	ldw	x, #0x505f
      00077C F6               [ 1] 1546 	ld	a, (x)
      00077D A5 08            [ 1] 1547 	bcp	a, #0x08
      00077F 27 F8            [ 1] 1548 	jreq	00101$
      000781 81               [ 4] 1549 	ret
                                   1550 ;	clock.c: 97: void defStart(_Bool pos){ //"r__3" стандартная функция при загрузке 
                                   1551 ;	-----------------------------------------
                                   1552 ;	 function defStart
                                   1553 ;	-----------------------------------------
      000782                       1554 _defStart:
                                   1555 ;	clock.c: 99: switch(pos) {
      000782 7B 03            [ 1] 1556 	ld	a, (0x03, sp)
      000784 A1 00            [ 1] 1557 	cp	a, #0x00
      000786 27 06            [ 1] 1558 	jreq	00101$
      000788 A1 01            [ 1] 1559 	cp	a, #0x01
      00078A 27 05            [ 1] 1560 	jreq	00102$
      00078C 20 06            [ 2] 1561 	jra	00103$
                                   1562 ;	clock.c: 100: case 0: clock();
      00078E                       1563 00101$:
      00078E CDr0ErE4         [ 4] 1564 	call	_clock
                                   1565 ;	clock.c: 101: case 1: dnClock();
      000791                       1566 00102$:
      000791 CDr0FrBA         [ 4] 1567 	call	_dnClock
                                   1568 ;	clock.c: 102: default: clock();
      000794                       1569 00103$:
                                   1570 ;	clock.c: 103: }
      000794 CCr0ErE4         [ 2] 1571 	jp	_clock
                                   1572 ;	clock.c: 109: _Bool setStat(_Bool st){
                                   1573 ;	-----------------------------------------
                                   1574 ;	 function setStat
                                   1575 ;	-----------------------------------------
      000797                       1576 _setStat:
      000797 52 06            [ 2] 1577 	sub	sp, #6
                                   1578 ;	clock.c: 111: TM1637_cleer();
      000799 CDr01r80         [ 4] 1579 	call	_TM1637_cleer
                                   1580 ;	clock.c: 112: Soft_Timer = 0x00;
      00079C 5F               [ 1] 1581 	clrw	x
      00079D CFu00u21         [ 2] 1582 	ldw	_Soft_Timer+0, x
                                   1583 ;	clock.c: 113: buff = st;
      0007A0 7B 09            [ 1] 1584 	ld	a, (0x09, sp)
      0007A2 C7u00u27         [ 1] 1585 	ld	_buff+0, a
                                   1586 ;	clock.c: 115: while(1){
      0007A5 AEr00r07         [ 2] 1587 	ldw	x, #_ASCI+0
      0007A8 1F 03            [ 2] 1588 	ldw	(0x03, sp), x
      0007AA                       1589 00108$:
                                   1590 ;	clock.c: 117: if(button(up) | button(dn))buff =! buff;
      0007AA 4B 05            [ 1] 1591 	push	#0x05
      0007AC CDr08r75         [ 4] 1592 	call	_button
      0007AF 5B 01            [ 2] 1593 	addw	sp, #1
      0007B1 6B 06            [ 1] 1594 	ld	(0x06, sp), a
      0007B3 4B 07            [ 1] 1595 	push	#0x07
      0007B5 CDr08r75         [ 4] 1596 	call	_button
      0007B8 5B 01            [ 2] 1597 	addw	sp, #1
      0007BA 1A 06            [ 1] 1598 	or	a, (0x06, sp)
      0007BC 4D               [ 1] 1599 	tnz	a
      0007BD 27 0A            [ 1] 1600 	jreq	00102$
      0007BF C6u00u27         [ 1] 1601 	ld	a, _buff+0
      0007C2 A0 01            [ 1] 1602 	sub	a, #0x01
      0007C4 4F               [ 1] 1603 	clr	a
      0007C5 49               [ 1] 1604 	rlc	a
      0007C6 C7u00u27         [ 1] 1605 	ld	_buff+0, a
      0007C9                       1606 00102$:
                                   1607 ;	clock.c: 119: if(button(ok)){
      0007C9 4B 06            [ 1] 1608 	push	#0x06
      0007CB CDr08r75         [ 4] 1609 	call	_button
      0007CE 5B 01            [ 2] 1610 	addw	sp, #1
      0007D0 6B 05            [ 1] 1611 	ld	(0x05, sp), a
      0007D2 0D 05            [ 1] 1612 	tnz	(0x05, sp)
      0007D4 27 05            [ 1] 1613 	jreq	00104$
                                   1614 ;	clock.c: 120: return buff;
      0007D6 C6u00u27         [ 1] 1615 	ld	a, _buff+0
      0007D9 20 3B            [ 2] 1616 	jra	00110$
      0007DB                       1617 00104$:
                                   1618 ;	clock.c: 123: Soft_Timer++;
      0007DB CEu00u21         [ 2] 1619 	ldw	x, _Soft_Timer+0
      0007DE 5C               [ 2] 1620 	incw	x
                                   1621 ;	clock.c: 124: if(Soft_Timer == 300){
      0007DF CFu00u21         [ 2] 1622 	ldw	_Soft_Timer+0, x
      0007E2 A3 01 2C         [ 2] 1623 	cpw	x, #0x012c
      0007E5 26 C3            [ 1] 1624 	jrne	00108$
                                   1625 ;	clock.c: 125: TM1637_sendMASS(0x50,0x08,0x00,ASCI[buff]);
      0007E7 AEr00r03         [ 2] 1626 	ldw	x, #_TM1637_seg+0
      0007EA 1F 01            [ 2] 1627 	ldw	(0x01, sp), x
      0007EC 1E 01            [ 2] 1628 	ldw	x, (0x01, sp)
      0007EE A6 50            [ 1] 1629 	ld	a, #0x50
      0007F0 F7               [ 1] 1630 	ld	(x), a
      0007F1 1E 01            [ 2] 1631 	ldw	x, (0x01, sp)
      0007F3 5C               [ 2] 1632 	incw	x
      0007F4 A6 08            [ 1] 1633 	ld	a, #0x08
      0007F6 F7               [ 1] 1634 	ld	(x), a
      0007F7 1E 01            [ 2] 1635 	ldw	x, (0x01, sp)
      0007F9 5C               [ 2] 1636 	incw	x
      0007FA 5C               [ 2] 1637 	incw	x
      0007FB 7F               [ 1] 1638 	clr	(x)
      0007FC 16 01            [ 2] 1639 	ldw	y, (0x01, sp)
      0007FE 72 A9 00 03      [ 2] 1640 	addw	y, #0x0003
      000802 5F               [ 1] 1641 	clrw	x
      000803 C6u00u27         [ 1] 1642 	ld	a, _buff+0
      000806 97               [ 1] 1643 	ld	xl, a
      000807 72 FB 03         [ 2] 1644 	addw	x, (0x03, sp)
      00080A F6               [ 1] 1645 	ld	a, (x)
      00080B 90 F7            [ 1] 1646 	ld	(y), a
      00080D CDr01r39         [ 4] 1647 	call	_TM1637_send
                                   1648 ;	clock.c: 126: Soft_Timer = 0x00;
      000810 5F               [ 1] 1649 	clrw	x
      000811 CFu00u21         [ 2] 1650 	ldw	_Soft_Timer+0, x
      000814 20 94            [ 2] 1651 	jra	00108$
      000816                       1652 00110$:
      000816 5B 06            [ 2] 1653 	addw	sp, #6
      000818 81               [ 4] 1654 	ret
                                   1655 ;	clock.c: 131: void main(){
                                   1656 ;	-----------------------------------------
                                   1657 ;	 function main
                                   1658 ;	-----------------------------------------
      000819                       1659 _main:
                                   1660 ;	clock.c: 133: PC_DDR &= ~(1<<ok) | (1<<dn) | (1<<up); //инициализация кнопок
      000819 AE 50 0C         [ 2] 1661 	ldw	x, #0x500c
      00081C F6               [ 1] 1662 	ld	a, (x)
      00081D A4 BF            [ 1] 1663 	and	a, #0xbf
      00081F F7               [ 1] 1664 	ld	(x), a
                                   1665 ;	clock.c: 135: CLK_CKDIVR= 0b00001000; //Настройка тактирования на 8MHz, 
      000820 35 08 50 C6      [ 1] 1666 	mov	0x50c6+0, #0x08
                                   1667 ;	clock.c: 137: TM1637_INIT();
      000824 AE 50 0C         [ 2] 1668 	ldw	x, #0x500c
      000827 F6               [ 1] 1669 	ld	a, (x)
      000828 AA 18            [ 1] 1670 	or	a, #0x18
      00082A F7               [ 1] 1671 	ld	(x), a
      00082B AE 50 0D         [ 2] 1672 	ldw	x, #0x500d
      00082E F6               [ 1] 1673 	ld	a, (x)
      00082F AA 18            [ 1] 1674 	or	a, #0x18
      000831 F7               [ 1] 1675 	ld	(x), a
      000832 CDr01r9F         [ 4] 1676 	call	_TM1637_initialization
                                   1677 ;	clock.c: 138: TM1637_brigh(EEPROM_DATA(setting_Brigh));
      000835 AE 40 00         [ 2] 1678 	ldw	x, #0x4000
      000838 F6               [ 1] 1679 	ld	a, (x)
      000839 88               [ 1] 1680 	push	a
      00083A CDr01r20         [ 4] 1681 	call	_TM1637_brigh
      00083D 84               [ 1] 1682 	pop	a
                                   1683 ;	clock.c: 139: I2C_INIT();
      00083E AE 50 07         [ 2] 1684 	ldw	x, #0x5007
      000841 F6               [ 1] 1685 	ld	a, (x)
      000842 AA 30            [ 1] 1686 	or	a, #0x30
      000844 F7               [ 1] 1687 	ld	(x), a
      000845 AE 50 08         [ 2] 1688 	ldw	x, #0x5008
      000848 F6               [ 1] 1689 	ld	a, (x)
      000849 AA 30            [ 1] 1690 	or	a, #0x30
      00084B F7               [ 1] 1691 	ld	(x), a
      00084C CDr02rFF         [ 4] 1692 	call	_i2c_init
                                   1693 ;	clock.c: 141: if(button(up) || button(dn))hard_Reset(); // Кнопки при включении зажать up + dn = hard reset
      00084F 4B 05            [ 1] 1694 	push	#0x05
      000851 CDr08r75         [ 4] 1695 	call	_button
      000854 5B 01            [ 2] 1696 	addw	sp, #1
      000856 4D               [ 1] 1697 	tnz	a
      000857 26 0A            [ 1] 1698 	jrne	00101$
      000859 4B 07            [ 1] 1699 	push	#0x07
      00085B CDr08r75         [ 4] 1700 	call	_button
      00085E 5B 01            [ 2] 1701 	addw	sp, #1
      000860 4D               [ 1] 1702 	tnz	a
      000861 27 03            [ 1] 1703 	jreq	00105$
      000863                       1704 00101$:
      000863 CDr08rD2         [ 4] 1705 	call	_hard_Reset
                                   1706 ;	clock.c: 144: while(1){
      000866                       1707 00105$:
                                   1708 ;	clock.c: 146: defStart(EEPROM_DATA(defStartER));
      000866 AE 40 08         [ 2] 1709 	ldw	x, #0x4008
      000869 F6               [ 1] 1710 	ld	a, (x)
      00086A 40               [ 1] 1711 	neg	a
      00086B 4F               [ 1] 1712 	clr	a
      00086C 49               [ 1] 1713 	rlc	a
      00086D 88               [ 1] 1714 	push	a
      00086E CDr07r82         [ 4] 1715 	call	_defStart
      000871 84               [ 1] 1716 	pop	a
      000872 20 F2            [ 2] 1717 	jra	00105$
      000874 81               [ 4] 1718 	ret
                                   1719 ;	clock.c: 154: char button(char but){ //Обработка кнопок
                                   1720 ;	-----------------------------------------
                                   1721 ;	 function button
                                   1722 ;	-----------------------------------------
      000875                       1723 _button:
      000875 52 04            [ 2] 1724 	sub	sp, #4
                                   1725 ;	clock.c: 156: if(!(PC_IDR&(1<<but))){
      000877 AE 50 0B         [ 2] 1726 	ldw	x, #0x500b
      00087A F6               [ 1] 1727 	ld	a, (x)
      00087B 95               [ 1] 1728 	ld	xh, a
      00087C 90 AE 00 01      [ 2] 1729 	ldw	y, #0x0001
      000880 17 03            [ 2] 1730 	ldw	(0x03, sp), y
      000882 7B 07            [ 1] 1731 	ld	a, (0x07, sp)
      000884 27 07            [ 1] 1732 	jreq	00117$
      000886                       1733 00116$:
      000886 08 04            [ 1] 1734 	sll	(0x04, sp)
      000888 09 03            [ 1] 1735 	rlc	(0x03, sp)
      00088A 4A               [ 1] 1736 	dec	a
      00088B 26 F9            [ 1] 1737 	jrne	00116$
      00088D                       1738 00117$:
      00088D 4F               [ 1] 1739 	clr	a
      00088E 97               [ 1] 1740 	ld	xl, a
                                   1741 ;	clock.c: 158: Buff_But &= ~(1 << but);
      00088F A6 01            [ 1] 1742 	ld	a, #0x01
      000891 90 97            [ 1] 1743 	ld	yl, a
      000893 7B 07            [ 1] 1744 	ld	a, (0x07, sp)
      000895 27 06            [ 1] 1745 	jreq	00119$
      000897                       1746 00118$:
      000897 61               [ 1] 1747 	exg	a, yl
      000898 48               [ 1] 1748 	sll	a
      000899 61               [ 1] 1749 	exg	a, yl
      00089A 4A               [ 1] 1750 	dec	a
      00089B 26 FA            [ 1] 1751 	jrne	00118$
      00089D                       1752 00119$:
                                   1753 ;	clock.c: 156: if(!(PC_IDR&(1<<but))){
      00089D 9E               [ 1] 1754 	ld	a, xh
      00089E 14 04            [ 1] 1755 	and	a, (0x04, sp)
      0008A0 6B 02            [ 1] 1756 	ld	(0x02, sp), a
      0008A2 9F               [ 1] 1757 	ld	a, xl
      0008A3 14 03            [ 1] 1758 	and	a, (0x03, sp)
      0008A5 6B 01            [ 1] 1759 	ld	(0x01, sp), a
      0008A7 1E 01            [ 2] 1760 	ldw	x, (0x01, sp)
      0008A9 26 1B            [ 1] 1761 	jrne	00104$
                                   1762 ;	clock.c: 157: if(Buff_But&(1 << but)){
      0008AB C6u00u25         [ 1] 1763 	ld	a, _Buff_But+0
      0008AE 95               [ 1] 1764 	ld	xh, a
      0008AF 4F               [ 1] 1765 	clr	a
      0008B0 14 03            [ 1] 1766 	and	a, (0x03, sp)
      0008B2 02               [ 1] 1767 	rlwa	x
      0008B3 14 04            [ 1] 1768 	and	a, (0x04, sp)
      0008B5 95               [ 1] 1769 	ld	xh, a
      0008B6 5D               [ 2] 1770 	tnzw	x
      0008B7 27 15            [ 1] 1771 	jreq	00105$
                                   1772 ;	clock.c: 158: Buff_But &= ~(1 << but);
      0008B9 90 9F            [ 1] 1773 	ld	a, yl
      0008BB 43               [ 1] 1774 	cpl	a
      0008BC C4u00u25         [ 1] 1775 	and	a, _Buff_But+0
      0008BF C7u00u25         [ 1] 1776 	ld	_Buff_But+0, a
                                   1777 ;	clock.c: 159: return but;
      0008C2 7B 07            [ 1] 1778 	ld	a, (0x07, sp)
      0008C4 20 09            [ 2] 1779 	jra	00106$
      0008C6                       1780 00104$:
                                   1781 ;	clock.c: 162: else Buff_But |= (1 << but);
      0008C6 90 9F            [ 1] 1782 	ld	a, yl
      0008C8 CAu00u25         [ 1] 1783 	or	a, _Buff_But+0
      0008CB C7u00u25         [ 1] 1784 	ld	_Buff_But+0, a
      0008CE                       1785 00105$:
                                   1786 ;	clock.c: 165: return 0;
      0008CE 4F               [ 1] 1787 	clr	a
      0008CF                       1788 00106$:
      0008CF 5B 04            [ 2] 1789 	addw	sp, #4
      0008D1 81               [ 4] 1790 	ret
                                   1791 ;	clock.c: 168: void hard_Reset(){ //default setting
                                   1792 ;	-----------------------------------------
                                   1793 ;	 function hard_Reset
                                   1794 ;	-----------------------------------------
      0008D2                       1795 _hard_Reset:
      0008D2 52 02            [ 2] 1796 	sub	sp, #2
                                   1797 ;	clock.c: 170: EEPROM_UNLOCK();
      0008D4 CDr07r71         [ 4] 1798 	call	_EEPROM_UNLOCK
                                   1799 ;	clock.c: 171: EEPROM_DATA(setting_Brigh) = 7;
      0008D7 35 07 40 00      [ 1] 1800 	mov	0x4000+0, #0x07
                                   1801 ;	clock.c: 173: EEPROM_DATA(DnClock_hour_0) = 0x00;
      0008DB 35 00 40 00      [ 1] 1802 	mov	0x4000+0, #0x00
                                   1803 ;	clock.c: 174: EEPROM_DATA(DnClock_min_0)	= 0x00;
      0008DF 35 00 40 01      [ 1] 1804 	mov	0x4001+0, #0x00
                                   1805 ;	clock.c: 176: EEPROM_DATA(DnClock_hour_1) = 0x00;
      0008E3 35 00 40 02      [ 1] 1806 	mov	0x4002+0, #0x00
                                   1807 ;	clock.c: 177: EEPROM_DATA(DnClock_min_1)	= 0x00;
      0008E7 35 00 40 03      [ 1] 1808 	mov	0x4003+0, #0x00
                                   1809 ;	clock.c: 179: EEPROM_DATA(DnClock_hour_2) = 0x00;
      0008EB 35 00 40 04      [ 1] 1810 	mov	0x4004+0, #0x00
                                   1811 ;	clock.c: 180: EEPROM_DATA(DnClock_min_2)	= 0x00;
      0008EF 35 00 40 05      [ 1] 1812 	mov	0x4005+0, #0x00
                                   1813 ;	clock.c: 182: EEPROM_DATA(DnClock_hour_3) = 0x00;
      0008F3 35 00 40 06      [ 1] 1814 	mov	0x4006+0, #0x00
                                   1815 ;	clock.c: 183: EEPROM_DATA(DnClock_min_3)	= 0x00;		
      0008F7 35 00 40 07      [ 1] 1816 	mov	0x4007+0, #0x00
                                   1817 ;	clock.c: 184: EEPROM_LOCK();
      0008FB AE 50 5F         [ 2] 1818 	ldw	x, #0x505f
      0008FE F6               [ 1] 1819 	ld	a, (x)
      0008FF A4 F7            [ 1] 1820 	and	a, #0xf7
      000901 F7               [ 1] 1821 	ld	(x), a
                                   1822 ;	clock.c: 186: RTC_Set(0, 0, 0, 1, 1, 1, 20); //reset RTC
      000902 4B 14            [ 1] 1823 	push	#0x14
      000904 4B 01            [ 1] 1824 	push	#0x01
      000906 4B 01            [ 1] 1825 	push	#0x01
      000908 4B 01            [ 1] 1826 	push	#0x01
      00090A 4B 00            [ 1] 1827 	push	#0x00
      00090C 4B 00            [ 1] 1828 	push	#0x00
      00090E 4B 00            [ 1] 1829 	push	#0x00
      000910 CDr05r8D         [ 4] 1830 	call	_RTC_Set
      000913 5B 07            [ 2] 1831 	addw	sp, #7
                                   1832 ;	clock.c: 189: TM1637_cleer();
      000915 CDr01r80         [ 4] 1833 	call	_TM1637_cleer
                                   1834 ;	clock.c: 190: TM1637_sendMASS(0x50,0x6D,0x78,0x00); //RESET
      000918 AEr00r03         [ 2] 1835 	ldw	x, #_TM1637_seg+0
      00091B 1F 01            [ 2] 1836 	ldw	(0x01, sp), x
      00091D 1E 01            [ 2] 1837 	ldw	x, (0x01, sp)
      00091F A6 50            [ 1] 1838 	ld	a, #0x50
      000921 F7               [ 1] 1839 	ld	(x), a
      000922 1E 01            [ 2] 1840 	ldw	x, (0x01, sp)
      000924 5C               [ 2] 1841 	incw	x
      000925 A6 6D            [ 1] 1842 	ld	a, #0x6d
      000927 F7               [ 1] 1843 	ld	(x), a
      000928 1E 01            [ 2] 1844 	ldw	x, (0x01, sp)
      00092A 5C               [ 2] 1845 	incw	x
      00092B 5C               [ 2] 1846 	incw	x
      00092C A6 78            [ 1] 1847 	ld	a, #0x78
      00092E F7               [ 1] 1848 	ld	(x), a
      00092F 1E 01            [ 2] 1849 	ldw	x, (0x01, sp)
      000931 1C 00 03         [ 2] 1850 	addw	x, #0x0003
      000934 7F               [ 1] 1851 	clr	(x)
      000935 CDr01r39         [ 4] 1852 	call	_TM1637_send
                                   1853 ;	clock.c: 191: delay(99999);
      000938 4B 9F            [ 1] 1854 	push	#0x9f
      00093A 4B 86            [ 1] 1855 	push	#0x86
      00093C 4B 01            [ 1] 1856 	push	#0x01
      00093E 4B 00            [ 1] 1857 	push	#0x00
      000940 CDr00r00         [ 4] 1858 	call	_delay
      000943 5B 04            [ 2] 1859 	addw	sp, #4
                                   1860 ;	clock.c: 193: WWDG_CR |= (1<<7); //software reset
      000945 AE 50 D1         [ 2] 1861 	ldw	x, #0x50d1
      000948 F6               [ 1] 1862 	ld	a, (x)
      000949 AA 80            [ 1] 1863 	or	a, #0x80
      00094B F7               [ 1] 1864 	ld	(x), a
                                   1865 ;	clock.c: 194: WWDG_CR = 0x40; 
      00094C 35 40 50 D1      [ 1] 1866 	mov	0x50d1+0, #0x40
                                   1867 ;	clock.c: 195: WWDG_CR = 0x3F;
      000950 35 3F 50 D1      [ 1] 1868 	mov	0x50d1+0, #0x3f
      000954 5B 02            [ 2] 1869 	addw	sp, #2
      000956 81               [ 4] 1870 	ret
                                   1871 ;	clock.c: 202: char Set_time(unsigned char hourset, unsigned char minset){
                                   1872 ;	-----------------------------------------
                                   1873 ;	 function Set_time
                                   1874 ;	-----------------------------------------
      000957                       1875 _Set_time:
      000957 52 0C            [ 2] 1876 	sub	sp, #12
                                   1877 ;	clock.c: 204: TM1637_cleer();
      000959 CDr01r80         [ 4] 1878 	call	_TM1637_cleer
                                   1879 ;	clock.c: 206: Soft_Timer = 0x00;
      00095C 5F               [ 1] 1880 	clrw	x
      00095D CFu00u21         [ 2] 1881 	ldw	_Soft_Timer+0, x
                                   1882 ;	clock.c: 209: while(1){
      000960 AEr00r07         [ 2] 1883 	ldw	x, #_ASCI+0
      000963 1F 0A            [ 2] 1884 	ldw	(0x0a, sp), x
      000965 AEr00r03         [ 2] 1885 	ldw	x, #_TM1637_seg+0
      000968 1F 08            [ 2] 1886 	ldw	(0x08, sp), x
      00096A 0F 01            [ 1] 1887 	clr	(0x01, sp)
      00096C                       1888 00140$:
                                   1889 ;	clock.c: 211: if(button(up)){
      00096C 4B 05            [ 1] 1890 	push	#0x05
      00096E CDr08r75         [ 4] 1891 	call	_button
      000971 5B 01            [ 2] 1892 	addw	sp, #1
      000973 95               [ 1] 1893 	ld	xh, a
                                   1894 ;	clock.c: 216: if(Point == 1){
      000974 7B 01            [ 1] 1895 	ld	a, (0x01, sp)
      000976 A1 01            [ 1] 1896 	cp	a, #0x01
      000978 26 06            [ 1] 1897 	jrne	00226$
      00097A A6 01            [ 1] 1898 	ld	a, #0x01
      00097C 6B 0C            [ 1] 1899 	ld	(0x0c, sp), a
      00097E 20 02            [ 2] 1900 	jra	00227$
      000980                       1901 00226$:
      000980 0F 0C            [ 1] 1902 	clr	(0x0c, sp)
      000982                       1903 00227$:
                                   1904 ;	clock.c: 211: if(button(up)){
      000982 9E               [ 1] 1905 	ld	a, xh
      000983 4D               [ 1] 1906 	tnz	a
      000984 27 1C            [ 1] 1907 	jreq	00110$
                                   1908 ;	clock.c: 212: if(Point == 0){
      000986 0D 01            [ 1] 1909 	tnz	(0x01, sp)
      000988 26 0A            [ 1] 1910 	jrne	00104$
                                   1911 ;	clock.c: 213: hourset++;
      00098A 0C 0F            [ 1] 1912 	inc	(0x0f, sp)
                                   1913 ;	clock.c: 214: if(hourset > 23)hourset = 0;
      00098C 7B 0F            [ 1] 1914 	ld	a, (0x0f, sp)
      00098E A1 17            [ 1] 1915 	cp	a, #0x17
      000990 23 02            [ 2] 1916 	jrule	00104$
      000992 0F 0F            [ 1] 1917 	clr	(0x0f, sp)
      000994                       1918 00104$:
                                   1919 ;	clock.c: 216: if(Point == 1){
      000994 0D 0C            [ 1] 1920 	tnz	(0x0c, sp)
      000996 27 0A            [ 1] 1921 	jreq	00110$
                                   1922 ;	clock.c: 217: minset++;
      000998 0C 10            [ 1] 1923 	inc	(0x10, sp)
                                   1924 ;	clock.c: 218: if(minset > 59)minset = 0;
      00099A 7B 10            [ 1] 1925 	ld	a, (0x10, sp)
      00099C A1 3B            [ 1] 1926 	cp	a, #0x3b
      00099E 23 02            [ 2] 1927 	jrule	00110$
      0009A0 0F 10            [ 1] 1928 	clr	(0x10, sp)
      0009A2                       1929 00110$:
                                   1930 ;	clock.c: 221: if(button(dn)){
      0009A2 4B 07            [ 1] 1931 	push	#0x07
      0009A4 CDr08r75         [ 4] 1932 	call	_button
      0009A7 5B 01            [ 2] 1933 	addw	sp, #1
      0009A9 4D               [ 1] 1934 	tnz	a
      0009AA 27 20            [ 1] 1935 	jreq	00120$
                                   1936 ;	clock.c: 222: if(Point == 0){
      0009AC 0D 01            [ 1] 1937 	tnz	(0x01, sp)
      0009AE 26 0C            [ 1] 1938 	jrne	00114$
                                   1939 ;	clock.c: 223: hourset--;
      0009B0 0A 0F            [ 1] 1940 	dec	(0x0f, sp)
                                   1941 ;	clock.c: 224: if(hourset > 23)hourset = 23;
      0009B2 7B 0F            [ 1] 1942 	ld	a, (0x0f, sp)
      0009B4 A1 17            [ 1] 1943 	cp	a, #0x17
      0009B6 23 04            [ 2] 1944 	jrule	00114$
      0009B8 A6 17            [ 1] 1945 	ld	a, #0x17
      0009BA 6B 0F            [ 1] 1946 	ld	(0x0f, sp), a
      0009BC                       1947 00114$:
                                   1948 ;	clock.c: 226: if(Point == 1){
      0009BC 0D 0C            [ 1] 1949 	tnz	(0x0c, sp)
      0009BE 27 0C            [ 1] 1950 	jreq	00120$
                                   1951 ;	clock.c: 227: minset--;
      0009C0 0A 10            [ 1] 1952 	dec	(0x10, sp)
                                   1953 ;	clock.c: 228: if(minset > 59)minset = 59;
      0009C2 7B 10            [ 1] 1954 	ld	a, (0x10, sp)
      0009C4 A1 3B            [ 1] 1955 	cp	a, #0x3b
      0009C6 23 04            [ 2] 1956 	jrule	00120$
      0009C8 A6 3B            [ 1] 1957 	ld	a, #0x3b
      0009CA 6B 10            [ 1] 1958 	ld	(0x10, sp), a
      0009CC                       1959 00120$:
                                   1960 ;	clock.c: 231: if(button(ok)){
      0009CC 4B 06            [ 1] 1961 	push	#0x06
      0009CE CDr08r75         [ 4] 1962 	call	_button
      0009D1 5B 01            [ 2] 1963 	addw	sp, #1
      0009D3 4D               [ 1] 1964 	tnz	a
      0009D4 27 02            [ 1] 1965 	jreq	00122$
                                   1966 ;	clock.c: 232: Point++;
      0009D6 0C 01            [ 1] 1967 	inc	(0x01, sp)
      0009D8                       1968 00122$:
                                   1969 ;	clock.c: 236: Soft_Timer++; //мигание
      0009D8 CEu00u21         [ 2] 1970 	ldw	x, _Soft_Timer+0
      0009DB 5C               [ 2] 1971 	incw	x
                                   1972 ;	clock.c: 237: if(Soft_Timer == 80){			
      0009DC CFu00u21         [ 2] 1973 	ldw	_Soft_Timer+0, x
      0009DF A3 00 50         [ 2] 1974 	cpw	x, #0x0050
      0009E2 26 0E            [ 1] 1975 	jrne	00124$
                                   1976 ;	clock.c: 238: dot = !dot;
      0009E4 C6u00u07         [ 1] 1977 	ld	a, _dot+0
      0009E7 A0 01            [ 1] 1978 	sub	a, #0x01
      0009E9 4F               [ 1] 1979 	clr	a
      0009EA 49               [ 1] 1980 	rlc	a
      0009EB C7u00u07         [ 1] 1981 	ld	_dot+0, a
                                   1982 ;	clock.c: 239: Soft_Timer = 0;
      0009EE 5F               [ 1] 1983 	clrw	x
      0009EF CFu00u21         [ 2] 1984 	ldw	_Soft_Timer+0, x
      0009F2                       1985 00124$:
                                   1986 ;	clock.c: 244: if(Point<2){ 
      0009F2 7B 01            [ 1] 1987 	ld	a, (0x01, sp)
      0009F4 A1 02            [ 1] 1988 	cp	a, #0x02
      0009F6 2F 03            [ 1] 1989 	jrslt	00242$
      0009F8 CCr0Ar85         [ 2] 1990 	jp	00136$
      0009FB                       1991 00242$:
                                   1992 ;	clock.c: 247: TM1637_seg[1] = 0x00;					
      0009FB 1E 08            [ 2] 1993 	ldw	x, (0x08, sp)
      0009FD 5C               [ 2] 1994 	incw	x
      0009FE 1F 04            [ 2] 1995 	ldw	(0x04, sp), x
                                   1996 ;	clock.c: 245: if(Point == 0 && dot == 1){
      000A00 0D 01            [ 1] 1997 	tnz	(0x01, sp)
      000A02 26 0F            [ 1] 1998 	jrne	00128$
      000A04 C6u00u07         [ 1] 1999 	ld	a, _dot+0
      000A07 A1 01            [ 1] 2000 	cp	a, #0x01
      000A09 26 08            [ 1] 2001 	jrne	00128$
                                   2002 ;	clock.c: 246: TM1637_seg[0] = 0x00;
      000A0B 1E 08            [ 2] 2003 	ldw	x, (0x08, sp)
      000A0D 7F               [ 1] 2004 	clr	(x)
                                   2005 ;	clock.c: 247: TM1637_seg[1] = 0x00;					
      000A0E 1E 04            [ 2] 2006 	ldw	x, (0x04, sp)
      000A10 7F               [ 1] 2007 	clr	(x)
      000A11 20 28            [ 2] 2008 	jra	00129$
      000A13                       2009 00128$:
                                   2010 ;	clock.c: 250: if(hourset/10)TM1637_seg[0] = ASCI[hourset/10];
      000A13 5F               [ 1] 2011 	clrw	x
      000A14 7B 0F            [ 1] 2012 	ld	a, (0x0f, sp)
      000A16 97               [ 1] 2013 	ld	xl, a
      000A17 A6 0A            [ 1] 2014 	ld	a, #0x0a
      000A19 62               [ 2] 2015 	div	x, a
      000A1A 9F               [ 1] 2016 	ld	a, xl
      000A1B 4D               [ 1] 2017 	tnz	a
      000A1C 27 0D            [ 1] 2018 	jreq	00126$
      000A1E 4F               [ 1] 2019 	clr	a
      000A1F 95               [ 1] 2020 	ld	xh, a
      000A20 72 FB 0A         [ 2] 2021 	addw	x, (0x0a, sp)
      000A23 1F 06            [ 2] 2022 	ldw	(0x06, sp), x
      000A25 1E 06            [ 2] 2023 	ldw	x, (0x06, sp)
      000A27 F6               [ 1] 2024 	ld	a, (x)
      000A28 1E 08            [ 2] 2025 	ldw	x, (0x08, sp)
      000A2A F7               [ 1] 2026 	ld	(x), a
      000A2B                       2027 00126$:
                                   2028 ;	clock.c: 251: TM1637_seg[1] = ASCI[hourset%10];		
      000A2B 5F               [ 1] 2029 	clrw	x
      000A2C 7B 0F            [ 1] 2030 	ld	a, (0x0f, sp)
      000A2E 97               [ 1] 2031 	ld	xl, a
      000A2F A6 0A            [ 1] 2032 	ld	a, #0x0a
      000A31 62               [ 2] 2033 	div	x, a
      000A32 5F               [ 1] 2034 	clrw	x
      000A33 97               [ 1] 2035 	ld	xl, a
      000A34 72 FB 0A         [ 2] 2036 	addw	x, (0x0a, sp)
      000A37 F6               [ 1] 2037 	ld	a, (x)
      000A38 1E 04            [ 2] 2038 	ldw	x, (0x04, sp)
      000A3A F7               [ 1] 2039 	ld	(x), a
      000A3B                       2040 00129$:
                                   2041 ;	clock.c: 254: TM1637_seg[1] = TM1637_seg[1] +0x80;
      000A3B 1E 04            [ 2] 2042 	ldw	x, (0x04, sp)
      000A3D F6               [ 1] 2043 	ld	a, (x)
      000A3E AB 80            [ 1] 2044 	add	a, #0x80
      000A40 1E 04            [ 2] 2045 	ldw	x, (0x04, sp)
      000A42 F7               [ 1] 2046 	ld	(x), a
                                   2047 ;	clock.c: 257: TM1637_seg[2] = 0x00;
      000A43 1E 08            [ 2] 2048 	ldw	x, (0x08, sp)
      000A45 5C               [ 2] 2049 	incw	x
      000A46 5C               [ 2] 2050 	incw	x
      000A47 1F 02            [ 2] 2051 	ldw	(0x02, sp), x
                                   2052 ;	clock.c: 258: TM1637_seg[3] = 0x00;					
      000A49 16 08            [ 2] 2053 	ldw	y, (0x08, sp)
      000A4B 72 A9 00 03      [ 2] 2054 	addw	y, #0x0003
                                   2055 ;	clock.c: 256: if(Point == 1 && dot == 1){
      000A4F 7B 01            [ 1] 2056 	ld	a, (0x01, sp)
      000A51 A1 01            [ 1] 2057 	cp	a, #0x01
      000A53 26 0E            [ 1] 2058 	jrne	00132$
      000A55 C6u00u07         [ 1] 2059 	ld	a, _dot+0
      000A58 A1 01            [ 1] 2060 	cp	a, #0x01
      000A5A 26 07            [ 1] 2061 	jrne	00132$
                                   2062 ;	clock.c: 257: TM1637_seg[2] = 0x00;
      000A5C 1E 02            [ 2] 2063 	ldw	x, (0x02, sp)
      000A5E 7F               [ 1] 2064 	clr	(x)
                                   2065 ;	clock.c: 258: TM1637_seg[3] = 0x00;					
      000A5F 90 7F            [ 1] 2066 	clr	(y)
      000A61 20 1F            [ 2] 2067 	jra	00133$
      000A63                       2068 00132$:
                                   2069 ;	clock.c: 261: TM1637_seg[2] = ASCI[minset/10];
      000A63 5F               [ 1] 2070 	clrw	x
      000A64 7B 10            [ 1] 2071 	ld	a, (0x10, sp)
      000A66 97               [ 1] 2072 	ld	xl, a
      000A67 A6 0A            [ 1] 2073 	ld	a, #0x0a
      000A69 62               [ 2] 2074 	div	x, a
      000A6A 4F               [ 1] 2075 	clr	a
      000A6B 95               [ 1] 2076 	ld	xh, a
      000A6C 72 FB 0A         [ 2] 2077 	addw	x, (0x0a, sp)
      000A6F F6               [ 1] 2078 	ld	a, (x)
      000A70 1E 02            [ 2] 2079 	ldw	x, (0x02, sp)
      000A72 F7               [ 1] 2080 	ld	(x), a
                                   2081 ;	clock.c: 262: TM1637_seg[3] = ASCI[minset%10];		
      000A73 5F               [ 1] 2082 	clrw	x
      000A74 7B 10            [ 1] 2083 	ld	a, (0x10, sp)
      000A76 97               [ 1] 2084 	ld	xl, a
      000A77 A6 0A            [ 1] 2085 	ld	a, #0x0a
      000A79 62               [ 2] 2086 	div	x, a
      000A7A 5F               [ 1] 2087 	clrw	x
      000A7B 97               [ 1] 2088 	ld	xl, a
      000A7C 72 FB 0A         [ 2] 2089 	addw	x, (0x0a, sp)
      000A7F F6               [ 1] 2090 	ld	a, (x)
      000A80 90 F7            [ 1] 2091 	ld	(y), a
      000A82                       2092 00133$:
                                   2093 ;	clock.c: 264: TM1637_send();				
      000A82 CDr01r39         [ 4] 2094 	call	_TM1637_send
      000A85                       2095 00136$:
                                   2096 ;	clock.c: 267: if(Point == 2){
      000A85 7B 01            [ 1] 2097 	ld	a, (0x01, sp)
      000A87 A1 02            [ 1] 2098 	cp	a, #0x02
      000A89 27 03            [ 1] 2099 	jreq	00256$
      000A8B CCr09r6C         [ 2] 2100 	jp	00140$
      000A8E                       2101 00256$:
                                   2102 ;	clock.c: 268: Clock_Temp[0] = hourset;
      000A8E AEr00r08         [ 2] 2103 	ldw	x, #_Clock_Temp+0
      000A91 7B 0F            [ 1] 2104 	ld	a, (0x0f, sp)
      000A93 F7               [ 1] 2105 	ld	(x), a
                                   2106 ;	clock.c: 269: Clock_Temp[1] = minset;
      000A94 5C               [ 2] 2107 	incw	x
      000A95 7B 10            [ 1] 2108 	ld	a, (0x10, sp)
      000A97 F7               [ 1] 2109 	ld	(x), a
                                   2110 ;	clock.c: 270: Soft_Timer = 0x00;
      000A98 5F               [ 1] 2111 	clrw	x
      000A99 CFu00u21         [ 2] 2112 	ldw	_Soft_Timer+0, x
                                   2113 ;	clock.c: 271: return 1;
      000A9C A6 01            [ 1] 2114 	ld	a, #0x01
      000A9E 5B 0C            [ 2] 2115 	addw	sp, #12
      000AA0 81               [ 4] 2116 	ret
                                   2117 ;	clock.c: 277: char Set_Brigh(){
                                   2118 ;	-----------------------------------------
                                   2119 ;	 function Set_Brigh
                                   2120 ;	-----------------------------------------
      000AA1                       2121 _Set_Brigh:
      000AA1 52 04            [ 2] 2122 	sub	sp, #4
                                   2123 ;	clock.c: 278: TM1637_cleer();
      000AA3 CDr01r80         [ 4] 2124 	call	_TM1637_cleer
                                   2125 ;	clock.c: 279: Soft_Timer = 0x00;
      000AA6 5F               [ 1] 2126 	clrw	x
      000AA7 CFu00u21         [ 2] 2127 	ldw	_Soft_Timer+0, x
                                   2128 ;	clock.c: 280: Point_Meny = EEPROM_DATA(setting_Brigh);
      000AAA AE 40 00         [ 2] 2129 	ldw	x, #0x4000
      000AAD F6               [ 1] 2130 	ld	a, (x)
      000AAE 97               [ 1] 2131 	ld	xl, a
      000AAF 49               [ 1] 2132 	rlc	a
      000AB0 4F               [ 1] 2133 	clr	a
      000AB1 A2 00            [ 1] 2134 	sbc	a, #0x00
      000AB3 95               [ 1] 2135 	ld	xh, a
      000AB4 CFu00u23         [ 2] 2136 	ldw	_Point_Meny+0, x
                                   2137 ;	clock.c: 282: auto_exit = 0;
      000AB7 72 5Fu00u26      [ 1] 2138 	clr	_auto_exit+0
                                   2139 ;	clock.c: 284: while(1){
      000ABB AEr00r07         [ 2] 2140 	ldw	x, #_ASCI+0
      000ABE 1F 01            [ 2] 2141 	ldw	(0x01, sp), x
      000AC0                       2142 00116$:
                                   2143 ;	clock.c: 286: if(button(up)){
      000AC0 4B 05            [ 1] 2144 	push	#0x05
      000AC2 CDr08r75         [ 4] 2145 	call	_button
      000AC5 5B 01            [ 2] 2146 	addw	sp, #1
      000AC7 4D               [ 1] 2147 	tnz	a
      000AC8 27 19            [ 1] 2148 	jreq	00104$
                                   2149 ;	clock.c: 287: Point_Meny++;
      000ACA CEu00u23         [ 2] 2150 	ldw	x, _Point_Meny+0
      000ACD 5C               [ 2] 2151 	incw	x
      000ACE CFu00u23         [ 2] 2152 	ldw	_Point_Meny+0, x
                                   2153 ;	clock.c: 288: auto_exit = 0;
      000AD1 72 5Fu00u26      [ 1] 2154 	clr	_auto_exit+0
                                   2155 ;	clock.c: 289: if(Point_Meny > 7)Point_Meny = 7;
      000AD5 CEu00u23         [ 2] 2156 	ldw	x, _Point_Meny+0
      000AD8 A3 00 07         [ 2] 2157 	cpw	x, #0x0007
      000ADB 23 06            [ 2] 2158 	jrule	00104$
      000ADD AE 00 07         [ 2] 2159 	ldw	x, #0x0007
      000AE0 CFu00u23         [ 2] 2160 	ldw	_Point_Meny+0, x
      000AE3                       2161 00104$:
                                   2162 ;	clock.c: 292: if(button(dn)){
      000AE3 4B 07            [ 1] 2163 	push	#0x07
      000AE5 CDr08r75         [ 4] 2164 	call	_button
      000AE8 5B 01            [ 2] 2165 	addw	sp, #1
      000AEA 4D               [ 1] 2166 	tnz	a
      000AEB 27 17            [ 1] 2167 	jreq	00108$
                                   2168 ;	clock.c: 293: Point_Meny--;
      000AED CEu00u23         [ 2] 2169 	ldw	x, _Point_Meny+0
      000AF0 5A               [ 2] 2170 	decw	x
      000AF1 CFu00u23         [ 2] 2171 	ldw	_Point_Meny+0, x
                                   2172 ;	clock.c: 294: auto_exit = 0;
      000AF4 72 5Fu00u26      [ 1] 2173 	clr	_auto_exit+0
                                   2174 ;	clock.c: 295: if(Point_Meny > 7)Point_Meny = 0;
      000AF8 CEu00u23         [ 2] 2175 	ldw	x, _Point_Meny+0
      000AFB A3 00 07         [ 2] 2176 	cpw	x, #0x0007
      000AFE 23 04            [ 2] 2177 	jrule	00108$
      000B00 5F               [ 1] 2178 	clrw	x
      000B01 CFu00u23         [ 2] 2179 	ldw	_Point_Meny+0, x
      000B04                       2180 00108$:
                                   2181 ;	clock.c: 297: if(button(ok)){
      000B04 4B 06            [ 1] 2182 	push	#0x06
      000B06 CDr08r75         [ 4] 2183 	call	_button
      000B09 5B 01            [ 2] 2184 	addw	sp, #1
      000B0B 4D               [ 1] 2185 	tnz	a
      000B0C 27 1A            [ 1] 2186 	jreq	00110$
                                   2187 ;	clock.c: 298: auto_exit = 0;
      000B0E 72 5Fu00u26      [ 1] 2188 	clr	_auto_exit+0
                                   2189 ;	clock.c: 300: EEPROM_UNLOCK();
      000B12 CDr07r71         [ 4] 2190 	call	_EEPROM_UNLOCK
                                   2191 ;	clock.c: 301: EEPROM_DATA(setting_Brigh) = Point_Meny;
      000B15 C6u00u24         [ 1] 2192 	ld	a, _Point_Meny+1
      000B18 AE 40 00         [ 2] 2193 	ldw	x, #0x4000
      000B1B F7               [ 1] 2194 	ld	(x), a
                                   2195 ;	clock.c: 302: EEPROM_LOCK();
      000B1C AE 50 5F         [ 2] 2196 	ldw	x, #0x505f
      000B1F F6               [ 1] 2197 	ld	a, (x)
      000B20 A4 F7            [ 1] 2198 	and	a, #0xf7
      000B22 F7               [ 1] 2199 	ld	(x), a
                                   2200 ;	clock.c: 304: return Point_Meny;
      000B23 C6u00u24         [ 1] 2201 	ld	a, _Point_Meny+1
      000B26 20 5F            [ 2] 2202 	jra	00118$
      000B28                       2203 00110$:
                                   2204 ;	clock.c: 308: Soft_Timer++;
      000B28 CEu00u21         [ 2] 2205 	ldw	x, _Soft_Timer+0
      000B2B 5C               [ 2] 2206 	incw	x
                                   2207 ;	clock.c: 309: if(Soft_Timer == 300){
      000B2C CFu00u21         [ 2] 2208 	ldw	_Soft_Timer+0, x
      000B2F A3 01 2C         [ 2] 2209 	cpw	x, #0x012c
      000B32 26 3A            [ 1] 2210 	jrne	00112$
                                   2211 ;	clock.c: 310: TM1637_sendMASS(0x7C,0x50,0x00,ASCI[Point_Meny]);
      000B34 AEr00r03         [ 2] 2212 	ldw	x, #_TM1637_seg+0
      000B37 1F 03            [ 2] 2213 	ldw	(0x03, sp), x
      000B39 1E 03            [ 2] 2214 	ldw	x, (0x03, sp)
      000B3B A6 7C            [ 1] 2215 	ld	a, #0x7c
      000B3D F7               [ 1] 2216 	ld	(x), a
      000B3E 1E 03            [ 2] 2217 	ldw	x, (0x03, sp)
      000B40 5C               [ 2] 2218 	incw	x
      000B41 A6 50            [ 1] 2219 	ld	a, #0x50
      000B43 F7               [ 1] 2220 	ld	(x), a
      000B44 1E 03            [ 2] 2221 	ldw	x, (0x03, sp)
      000B46 5C               [ 2] 2222 	incw	x
      000B47 5C               [ 2] 2223 	incw	x
      000B48 7F               [ 1] 2224 	clr	(x)
      000B49 16 03            [ 2] 2225 	ldw	y, (0x03, sp)
      000B4B 72 A9 00 03      [ 2] 2226 	addw	y, #0x0003
      000B4F 1E 01            [ 2] 2227 	ldw	x, (0x01, sp)
      000B51 72 BBu00u23      [ 2] 2228 	addw	x, _Point_Meny+0
      000B55 F6               [ 1] 2229 	ld	a, (x)
      000B56 90 F7            [ 1] 2230 	ld	(y), a
      000B58 CDr01r39         [ 4] 2231 	call	_TM1637_send
                                   2232 ;	clock.c: 311: TM1637_brigh(Point_Meny);
      000B5B C6u00u24         [ 1] 2233 	ld	a, _Point_Meny+1
      000B5E 88               [ 1] 2234 	push	a
      000B5F CDr01r20         [ 4] 2235 	call	_TM1637_brigh
      000B62 84               [ 1] 2236 	pop	a
                                   2237 ;	clock.c: 312: Soft_Timer = 0x00;
      000B63 5F               [ 1] 2238 	clrw	x
      000B64 CFu00u21         [ 2] 2239 	ldw	_Soft_Timer+0, x
                                   2240 ;	clock.c: 313: auto_exit++;
      000B67 C6u00u26         [ 1] 2241 	ld	a, _auto_exit+0
      000B6A 4C               [ 1] 2242 	inc	a
      000B6B C7u00u26         [ 1] 2243 	ld	_auto_exit+0, a
      000B6E                       2244 00112$:
                                   2245 ;	clock.c: 317: if(auto_exit == 100){
      000B6E C6u00u26         [ 1] 2246 	ld	a, _auto_exit+0
      000B71 A1 64            [ 1] 2247 	cp	a, #0x64
      000B73 27 03            [ 1] 2248 	jreq	00162$
      000B75 CCr0ArC0         [ 2] 2249 	jp	00116$
      000B78                       2250 00162$:
                                   2251 ;	clock.c: 319: TM1637_brigh(EEPROM_DATA(setting_Brigh));
      000B78 AE 40 00         [ 2] 2252 	ldw	x, #0x4000
      000B7B F6               [ 1] 2253 	ld	a, (x)
      000B7C 88               [ 1] 2254 	push	a
      000B7D CDr01r20         [ 4] 2255 	call	_TM1637_brigh
      000B80 84               [ 1] 2256 	pop	a
                                   2257 ;	clock.c: 320: clock();
      000B81 CDr0ErE4         [ 4] 2258 	call	_clock
      000B84 CCr0ArC0         [ 2] 2259 	jp	00116$
      000B87                       2260 00118$:
      000B87 5B 04            [ 2] 2261 	addw	sp, #4
      000B89 81               [ 4] 2262 	ret
                                   2263 ;	clock.c: 329: void Set_DnTimer(){ //"r__1"
                                   2264 ;	-----------------------------------------
                                   2265 ;	 function Set_DnTimer
                                   2266 ;	-----------------------------------------
      000B8A                       2267 _Set_DnTimer:
      000B8A 52 02            [ 2] 2268 	sub	sp, #2
                                   2269 ;	clock.c: 330: TM1637_cleer();
      000B8C CDr01r80         [ 4] 2270 	call	_TM1637_cleer
                                   2271 ;	clock.c: 331: Point_Meny = 0;
      000B8F 5F               [ 1] 2272 	clrw	x
      000B90 CFu00u23         [ 2] 2273 	ldw	_Point_Meny+0, x
                                   2274 ;	clock.c: 332: Soft_Timer = 0x00;
      000B93 5F               [ 1] 2275 	clrw	x
      000B94 CFu00u21         [ 2] 2276 	ldw	_Soft_Timer+0, x
                                   2277 ;	clock.c: 334: while(1){
      000B97                       2278 00124$:
                                   2279 ;	clock.c: 335: if(button(up)){
      000B97 4B 05            [ 1] 2280 	push	#0x05
      000B99 CDr08r75         [ 4] 2281 	call	_button
      000B9C 5B 01            [ 2] 2282 	addw	sp, #1
      000B9E 4D               [ 1] 2283 	tnz	a
      000B9F 27 10            [ 1] 2284 	jreq	00104$
                                   2285 ;	clock.c: 336: Point_Meny++;
      000BA1 CEu00u23         [ 2] 2286 	ldw	x, _Point_Meny+0
      000BA4 5C               [ 2] 2287 	incw	x
                                   2288 ;	clock.c: 337: if(Point_Meny > 4)Point_Meny = 0;
      000BA5 CFu00u23         [ 2] 2289 	ldw	_Point_Meny+0, x
      000BA8 A3 00 04         [ 2] 2290 	cpw	x, #0x0004
      000BAB 23 04            [ 2] 2291 	jrule	00104$
      000BAD 5F               [ 1] 2292 	clrw	x
      000BAE CFu00u23         [ 2] 2293 	ldw	_Point_Meny+0, x
      000BB1                       2294 00104$:
                                   2295 ;	clock.c: 340: if(button(dn)){
      000BB1 4B 07            [ 1] 2296 	push	#0x07
      000BB3 CDr08r75         [ 4] 2297 	call	_button
      000BB6 5B 01            [ 2] 2298 	addw	sp, #1
      000BB8 4D               [ 1] 2299 	tnz	a
      000BB9 27 12            [ 1] 2300 	jreq	00108$
                                   2301 ;	clock.c: 341: Point_Meny--;
      000BBB CEu00u23         [ 2] 2302 	ldw	x, _Point_Meny+0
      000BBE 5A               [ 2] 2303 	decw	x
                                   2304 ;	clock.c: 342: if(Point_Meny > 4)Point_Meny = 4;
      000BBF CFu00u23         [ 2] 2305 	ldw	_Point_Meny+0, x
      000BC2 A3 00 04         [ 2] 2306 	cpw	x, #0x0004
      000BC5 23 06            [ 2] 2307 	jrule	00108$
      000BC7 AE 00 04         [ 2] 2308 	ldw	x, #0x0004
      000BCA CFu00u23         [ 2] 2309 	ldw	_Point_Meny+0, x
      000BCD                       2310 00108$:
                                   2311 ;	clock.c: 345: if(button(ok)){
      000BCD 4B 06            [ 1] 2312 	push	#0x06
      000BCF CDr08r75         [ 4] 2313 	call	_button
      000BD2 5B 01            [ 2] 2314 	addw	sp, #1
      000BD4 4D               [ 1] 2315 	tnz	a
      000BD5 26 03            [ 1] 2316 	jrne	00180$
      000BD7 CCr0CrC0         [ 2] 2317 	jp	00120$
      000BDA                       2318 00180$:
                                   2319 ;	clock.c: 348: if(Point_Meny == 0){
      000BDA CEu00u23         [ 2] 2320 	ldw	x, _Point_Meny+0
      000BDD 26 2E            [ 1] 2321 	jrne	00110$
                                   2322 ;	clock.c: 349: Set_time(EEPROM_DATA(DnClock_hour_0),EEPROM_DATA(DnClock_min_0));
      000BDF AE 40 01         [ 2] 2323 	ldw	x, #0x4001
      000BE2 F6               [ 1] 2324 	ld	a, (x)
      000BE3 AE 40 00         [ 2] 2325 	ldw	x, #0x4000
      000BE6 88               [ 1] 2326 	push	a
      000BE7 F6               [ 1] 2327 	ld	a, (x)
      000BE8 95               [ 1] 2328 	ld	xh, a
      000BE9 88               [ 1] 2329 	push	a
      000BEA CDr09r57         [ 4] 2330 	call	_Set_time
      000BED 5B 02            [ 2] 2331 	addw	sp, #2
                                   2332 ;	clock.c: 350: EEPROM_UNLOCK();
      000BEF CDr07r71         [ 4] 2333 	call	_EEPROM_UNLOCK
                                   2334 ;	clock.c: 351: EEPROM_DATA(DnClock_hour_0) = Clock_Temp[0];
      000BF2 AEr00r08         [ 2] 2335 	ldw	x, #_Clock_Temp+0
      000BF5 F6               [ 1] 2336 	ld	a, (x)
      000BF6 90 AE 40 00      [ 2] 2337 	ldw	y, #0x4000
      000BFA 90 F7            [ 1] 2338 	ld	(y), a
                                   2339 ;	clock.c: 352: EEPROM_DATA(DnClock_min_0)	= Clock_Temp[1];
      000BFC E6 01            [ 1] 2340 	ld	a, (0x1, x)
      000BFE AE 40 01         [ 2] 2341 	ldw	x, #0x4001
      000C01 F7               [ 1] 2342 	ld	(x), a
                                   2343 ;	clock.c: 353: EEPROM_LOCK();
      000C02 AE 50 5F         [ 2] 2344 	ldw	x, #0x505f
      000C05 F6               [ 1] 2345 	ld	a, (x)
      000C06 A4 F7            [ 1] 2346 	and	a, #0xf7
      000C08 F7               [ 1] 2347 	ld	(x), a
                                   2348 ;	clock.c: 354: Point_Meny = 0;
      000C09 5F               [ 1] 2349 	clrw	x
      000C0A CFu00u23         [ 2] 2350 	ldw	_Point_Meny+0, x
      000C0D                       2351 00110$:
                                   2352 ;	clock.c: 357: if(Point_Meny == 1){
      000C0D CEu00u23         [ 2] 2353 	ldw	x, _Point_Meny+0
      000C10 A3 00 01         [ 2] 2354 	cpw	x, #0x0001
      000C13 26 30            [ 1] 2355 	jrne	00112$
                                   2356 ;	clock.c: 358: Set_time(EEPROM_DATA(DnClock_hour_1),EEPROM_DATA(DnClock_min_1));
      000C15 AE 40 03         [ 2] 2357 	ldw	x, #0x4003
      000C18 F6               [ 1] 2358 	ld	a, (x)
      000C19 AE 40 02         [ 2] 2359 	ldw	x, #0x4002
      000C1C 88               [ 1] 2360 	push	a
      000C1D F6               [ 1] 2361 	ld	a, (x)
      000C1E 95               [ 1] 2362 	ld	xh, a
      000C1F 88               [ 1] 2363 	push	a
      000C20 CDr09r57         [ 4] 2364 	call	_Set_time
      000C23 5B 02            [ 2] 2365 	addw	sp, #2
                                   2366 ;	clock.c: 359: EEPROM_UNLOCK();
      000C25 CDr07r71         [ 4] 2367 	call	_EEPROM_UNLOCK
                                   2368 ;	clock.c: 360: EEPROM_DATA(DnClock_hour_1) = Clock_Temp[0];
      000C28 AEr00r08         [ 2] 2369 	ldw	x, #_Clock_Temp+0
      000C2B F6               [ 1] 2370 	ld	a, (x)
      000C2C 90 AE 40 02      [ 2] 2371 	ldw	y, #0x4002
      000C30 90 F7            [ 1] 2372 	ld	(y), a
                                   2373 ;	clock.c: 361: EEPROM_DATA(DnClock_min_1)	= Clock_Temp[1];
      000C32 E6 01            [ 1] 2374 	ld	a, (0x1, x)
      000C34 AE 40 03         [ 2] 2375 	ldw	x, #0x4003
      000C37 F7               [ 1] 2376 	ld	(x), a
                                   2377 ;	clock.c: 362: EEPROM_LOCK();
      000C38 AE 50 5F         [ 2] 2378 	ldw	x, #0x505f
      000C3B F6               [ 1] 2379 	ld	a, (x)
      000C3C A4 F7            [ 1] 2380 	and	a, #0xf7
      000C3E F7               [ 1] 2381 	ld	(x), a
                                   2382 ;	clock.c: 363: Point_Meny = 1;
      000C3F AE 00 01         [ 2] 2383 	ldw	x, #0x0001
      000C42 CFu00u23         [ 2] 2384 	ldw	_Point_Meny+0, x
      000C45                       2385 00112$:
                                   2386 ;	clock.c: 366: if(Point_Meny == 2){
      000C45 CEu00u23         [ 2] 2387 	ldw	x, _Point_Meny+0
      000C48 A3 00 02         [ 2] 2388 	cpw	x, #0x0002
      000C4B 26 30            [ 1] 2389 	jrne	00114$
                                   2390 ;	clock.c: 367: Set_time(EEPROM_DATA(DnClock_hour_2),EEPROM_DATA(DnClock_min_2));
      000C4D AE 40 05         [ 2] 2391 	ldw	x, #0x4005
      000C50 F6               [ 1] 2392 	ld	a, (x)
      000C51 AE 40 04         [ 2] 2393 	ldw	x, #0x4004
      000C54 88               [ 1] 2394 	push	a
      000C55 F6               [ 1] 2395 	ld	a, (x)
      000C56 95               [ 1] 2396 	ld	xh, a
      000C57 88               [ 1] 2397 	push	a
      000C58 CDr09r57         [ 4] 2398 	call	_Set_time
      000C5B 5B 02            [ 2] 2399 	addw	sp, #2
                                   2400 ;	clock.c: 368: EEPROM_UNLOCK();
      000C5D CDr07r71         [ 4] 2401 	call	_EEPROM_UNLOCK
                                   2402 ;	clock.c: 369: EEPROM_DATA(DnClock_hour_2) = Clock_Temp[0];
      000C60 AEr00r08         [ 2] 2403 	ldw	x, #_Clock_Temp+0
      000C63 F6               [ 1] 2404 	ld	a, (x)
      000C64 90 AE 40 04      [ 2] 2405 	ldw	y, #0x4004
      000C68 90 F7            [ 1] 2406 	ld	(y), a
                                   2407 ;	clock.c: 370: EEPROM_DATA(DnClock_min_2)	= Clock_Temp[1];
      000C6A E6 01            [ 1] 2408 	ld	a, (0x1, x)
      000C6C AE 40 05         [ 2] 2409 	ldw	x, #0x4005
      000C6F F7               [ 1] 2410 	ld	(x), a
                                   2411 ;	clock.c: 371: EEPROM_LOCK();
      000C70 AE 50 5F         [ 2] 2412 	ldw	x, #0x505f
      000C73 F6               [ 1] 2413 	ld	a, (x)
      000C74 A4 F7            [ 1] 2414 	and	a, #0xf7
      000C76 F7               [ 1] 2415 	ld	(x), a
                                   2416 ;	clock.c: 372: Point_Meny = 2;
      000C77 AE 00 02         [ 2] 2417 	ldw	x, #0x0002
      000C7A CFu00u23         [ 2] 2418 	ldw	_Point_Meny+0, x
      000C7D                       2419 00114$:
                                   2420 ;	clock.c: 375: if(Point_Meny == 3){
      000C7D CEu00u23         [ 2] 2421 	ldw	x, _Point_Meny+0
      000C80 A3 00 03         [ 2] 2422 	cpw	x, #0x0003
      000C83 26 30            [ 1] 2423 	jrne	00116$
                                   2424 ;	clock.c: 376: Set_time(EEPROM_DATA(DnClock_hour_3),EEPROM_DATA(DnClock_min_3));
      000C85 AE 40 07         [ 2] 2425 	ldw	x, #0x4007
      000C88 F6               [ 1] 2426 	ld	a, (x)
      000C89 AE 40 06         [ 2] 2427 	ldw	x, #0x4006
      000C8C 88               [ 1] 2428 	push	a
      000C8D F6               [ 1] 2429 	ld	a, (x)
      000C8E 95               [ 1] 2430 	ld	xh, a
      000C8F 88               [ 1] 2431 	push	a
      000C90 CDr09r57         [ 4] 2432 	call	_Set_time
      000C93 5B 02            [ 2] 2433 	addw	sp, #2
                                   2434 ;	clock.c: 377: EEPROM_UNLOCK();
      000C95 CDr07r71         [ 4] 2435 	call	_EEPROM_UNLOCK
                                   2436 ;	clock.c: 378: EEPROM_DATA(DnClock_hour_3) = Clock_Temp[0];
      000C98 AEr00r08         [ 2] 2437 	ldw	x, #_Clock_Temp+0
      000C9B F6               [ 1] 2438 	ld	a, (x)
      000C9C 90 AE 40 06      [ 2] 2439 	ldw	y, #0x4006
      000CA0 90 F7            [ 1] 2440 	ld	(y), a
                                   2441 ;	clock.c: 379: EEPROM_DATA(DnClock_min_3)	= Clock_Temp[1];
      000CA2 E6 01            [ 1] 2442 	ld	a, (0x1, x)
      000CA4 AE 40 07         [ 2] 2443 	ldw	x, #0x4007
      000CA7 F7               [ 1] 2444 	ld	(x), a
                                   2445 ;	clock.c: 380: EEPROM_LOCK();
      000CA8 AE 50 5F         [ 2] 2446 	ldw	x, #0x505f
      000CAB F6               [ 1] 2447 	ld	a, (x)
      000CAC A4 F7            [ 1] 2448 	and	a, #0xf7
      000CAE F7               [ 1] 2449 	ld	(x), a
                                   2450 ;	clock.c: 381: Point_Meny = 3;
      000CAF AE 00 03         [ 2] 2451 	ldw	x, #0x0003
      000CB2 CFu00u23         [ 2] 2452 	ldw	_Point_Meny+0, x
      000CB5                       2453 00116$:
                                   2454 ;	clock.c: 387: if(Point_Meny == 4)clock(); //exit
      000CB5 CEu00u23         [ 2] 2455 	ldw	x, _Point_Meny+0
      000CB8 A3 00 04         [ 2] 2456 	cpw	x, #0x0004
      000CBB 26 03            [ 1] 2457 	jrne	00120$
      000CBD CDr0ErE4         [ 4] 2458 	call	_clock
      000CC0                       2459 00120$:
                                   2460 ;	clock.c: 394: Soft_Timer++;
      000CC0 CEu00u21         [ 2] 2461 	ldw	x, _Soft_Timer+0
      000CC3 5C               [ 2] 2462 	incw	x
                                   2463 ;	clock.c: 395: if(Soft_Timer == 300){
      000CC4 CFu00u21         [ 2] 2464 	ldw	_Soft_Timer+0, x
      000CC7 A3 01 2C         [ 2] 2465 	cpw	x, #0x012c
      000CCA 27 03            [ 1] 2466 	jreq	00196$
      000CCC CCr0Br97         [ 2] 2467 	jp	00124$
      000CCF                       2468 00196$:
                                   2469 ;	clock.c: 396: TM1637_sendMASS(0x5E,0x78,0x08,ASCI[Point_Meny]);
      000CCF AEr00r03         [ 2] 2470 	ldw	x, #_TM1637_seg+0
      000CD2 1F 01            [ 2] 2471 	ldw	(0x01, sp), x
      000CD4 1E 01            [ 2] 2472 	ldw	x, (0x01, sp)
      000CD6 A6 5E            [ 1] 2473 	ld	a, #0x5e
      000CD8 F7               [ 1] 2474 	ld	(x), a
      000CD9 1E 01            [ 2] 2475 	ldw	x, (0x01, sp)
      000CDB 5C               [ 2] 2476 	incw	x
      000CDC A6 78            [ 1] 2477 	ld	a, #0x78
      000CDE F7               [ 1] 2478 	ld	(x), a
      000CDF 1E 01            [ 2] 2479 	ldw	x, (0x01, sp)
      000CE1 5C               [ 2] 2480 	incw	x
      000CE2 5C               [ 2] 2481 	incw	x
      000CE3 A6 08            [ 1] 2482 	ld	a, #0x08
      000CE5 F7               [ 1] 2483 	ld	(x), a
      000CE6 16 01            [ 2] 2484 	ldw	y, (0x01, sp)
      000CE8 72 A9 00 03      [ 2] 2485 	addw	y, #0x0003
      000CEC AEr00r07         [ 2] 2486 	ldw	x, #_ASCI+0
      000CEF 72 BBu00u23      [ 2] 2487 	addw	x, _Point_Meny+0
      000CF3 F6               [ 1] 2488 	ld	a, (x)
      000CF4 90 F7            [ 1] 2489 	ld	(y), a
      000CF6 CDr01r39         [ 4] 2490 	call	_TM1637_send
                                   2491 ;	clock.c: 397: Soft_Timer = 0x00;
      000CF9 5F               [ 1] 2492 	clrw	x
      000CFA CFu00u21         [ 2] 2493 	ldw	_Soft_Timer+0, x
      000CFD CCr0Br97         [ 2] 2494 	jp	00124$
      000D00 5B 02            [ 2] 2495 	addw	sp, #2
      000D02 81               [ 4] 2496 	ret
                                   2497 ;	clock.c: 402: void Set_Meny(){ //Настройки "C__2"
                                   2498 ;	-----------------------------------------
                                   2499 ;	 function Set_Meny
                                   2500 ;	-----------------------------------------
      000D03                       2501 _Set_Meny:
      000D03 52 02            [ 2] 2502 	sub	sp, #2
                                   2503 ;	clock.c: 404: TM1637_cleer();
      000D05 CDr01r80         [ 4] 2504 	call	_TM1637_cleer
                                   2505 ;	clock.c: 405: Point_Meny = 0;
      000D08 5F               [ 1] 2506 	clrw	x
      000D09 CFu00u23         [ 2] 2507 	ldw	_Point_Meny+0, x
                                   2508 ;	clock.c: 406: Soft_Timer = 0x00;
      000D0C 5F               [ 1] 2509 	clrw	x
      000D0D CFu00u21         [ 2] 2510 	ldw	_Soft_Timer+0, x
                                   2511 ;	clock.c: 408: while(1){
      000D10                       2512 00126$:
                                   2513 ;	clock.c: 410: if(button(up)){
      000D10 4B 05            [ 1] 2514 	push	#0x05
      000D12 CDr08r75         [ 4] 2515 	call	_button
      000D15 5B 01            [ 2] 2516 	addw	sp, #1
      000D17 4D               [ 1] 2517 	tnz	a
      000D18 27 10            [ 1] 2518 	jreq	00104$
                                   2519 ;	clock.c: 411: Point_Meny++;
      000D1A CEu00u23         [ 2] 2520 	ldw	x, _Point_Meny+0
      000D1D 5C               [ 2] 2521 	incw	x
                                   2522 ;	clock.c: 412: if(Point_Meny > 5)Point_Meny = 0;
      000D1E CFu00u23         [ 2] 2523 	ldw	_Point_Meny+0, x
      000D21 A3 00 05         [ 2] 2524 	cpw	x, #0x0005
      000D24 23 04            [ 2] 2525 	jrule	00104$
      000D26 5F               [ 1] 2526 	clrw	x
      000D27 CFu00u23         [ 2] 2527 	ldw	_Point_Meny+0, x
      000D2A                       2528 00104$:
                                   2529 ;	clock.c: 415: if(button(dn)){
      000D2A 4B 07            [ 1] 2530 	push	#0x07
      000D2C CDr08r75         [ 4] 2531 	call	_button
      000D2F 5B 01            [ 2] 2532 	addw	sp, #1
      000D31 4D               [ 1] 2533 	tnz	a
      000D32 27 12            [ 1] 2534 	jreq	00108$
                                   2535 ;	clock.c: 416: Point_Meny--;
      000D34 CEu00u23         [ 2] 2536 	ldw	x, _Point_Meny+0
      000D37 5A               [ 2] 2537 	decw	x
                                   2538 ;	clock.c: 417: if(Point_Meny > 5)Point_Meny = 5;
      000D38 CFu00u23         [ 2] 2539 	ldw	_Point_Meny+0, x
      000D3B A3 00 05         [ 2] 2540 	cpw	x, #0x0005
      000D3E 23 06            [ 2] 2541 	jrule	00108$
      000D40 AE 00 05         [ 2] 2542 	ldw	x, #0x0005
      000D43 CFu00u23         [ 2] 2543 	ldw	_Point_Meny+0, x
      000D46                       2544 00108$:
                                   2545 ;	clock.c: 420: if(button(ok)){
      000D46 4B 06            [ 1] 2546 	push	#0x06
      000D48 CDr08r75         [ 4] 2547 	call	_button
      000D4B 5B 01            [ 2] 2548 	addw	sp, #1
      000D4D 4D               [ 1] 2549 	tnz	a
      000D4E 26 03            [ 1] 2550 	jrne	00186$
      000D50 CCr0DrEE         [ 2] 2551 	jp	00122$
      000D53                       2552 00186$:
                                   2553 ;	clock.c: 422: if(Point_Meny == 0){ //тут настройка RTC
      000D53 CEu00u23         [ 2] 2554 	ldw	x, _Point_Meny+0
      000D56 26 2C            [ 1] 2555 	jrne	00110$
                                   2556 ;	clock.c: 423: RTC_Read();
      000D58 CDr04rDE         [ 4] 2557 	call	_RTC_Read
                                   2558 ;	clock.c: 424: Set_time(hour,min);
      000D5B 3Bu00u01         [ 1] 2559 	push	_min+0
      000D5E 3Bu00u02         [ 1] 2560 	push	_hour+0
      000D61 CDr09r57         [ 4] 2561 	call	_Set_time
      000D64 5B 02            [ 2] 2562 	addw	sp, #2
                                   2563 ;	clock.c: 425: RTC_Set(0, Clock_Temp[1], Clock_Temp[0], 1, 1, 1, 20);
      000D66 AEr00r08         [ 2] 2564 	ldw	x, #_Clock_Temp+0
      000D69 F6               [ 1] 2565 	ld	a, (x)
      000D6A 88               [ 1] 2566 	push	a
      000D6B E6 01            [ 1] 2567 	ld	a, (0x1, x)
      000D6D 97               [ 1] 2568 	ld	xl, a
      000D6E 84               [ 1] 2569 	pop	a
      000D6F 4B 14            [ 1] 2570 	push	#0x14
      000D71 4B 01            [ 1] 2571 	push	#0x01
      000D73 4B 01            [ 1] 2572 	push	#0x01
      000D75 4B 01            [ 1] 2573 	push	#0x01
      000D77 88               [ 1] 2574 	push	a
      000D78 9F               [ 1] 2575 	ld	a, xl
      000D79 88               [ 1] 2576 	push	a
      000D7A 4B 00            [ 1] 2577 	push	#0x00
      000D7C CDr05r8D         [ 4] 2578 	call	_RTC_Set
      000D7F 5B 07            [ 2] 2579 	addw	sp, #7
                                   2580 ;	clock.c: 426: clock();
      000D81 CDr0ErE4         [ 4] 2581 	call	_clock
      000D84                       2582 00110$:
                                   2583 ;	clock.c: 429: if(Point_Meny == 1)Set_DnTimer();
      000D84 CEu00u23         [ 2] 2584 	ldw	x, _Point_Meny+0
      000D87 A3 00 01         [ 2] 2585 	cpw	x, #0x0001
      000D8A 26 03            [ 1] 2586 	jrne	00112$
      000D8C CDr0Br8A         [ 4] 2587 	call	_Set_DnTimer
      000D8F                       2588 00112$:
                                   2589 ;	clock.c: 431: if(Point_Meny == 3){ //Настройка загрузки при включении "r__3"
      000D8F CEu00u23         [ 2] 2590 	ldw	x, _Point_Meny+0
      000D92 A3 00 03         [ 2] 2591 	cpw	x, #0x0003
      000D95 26 1B            [ 1] 2592 	jrne	00114$
                                   2593 ;	clock.c: 432: EEPROM_UNLOCK();
      000D97 CDr07r71         [ 4] 2594 	call	_EEPROM_UNLOCK
                                   2595 ;	clock.c: 433: EEPROM_DATA(defStartER) = setStat(EEPROM_DATA(defStartER)); 
      000D9A AE 40 08         [ 2] 2596 	ldw	x, #0x4008
      000D9D F6               [ 1] 2597 	ld	a, (x)
      000D9E 40               [ 1] 2598 	neg	a
      000D9F 4F               [ 1] 2599 	clr	a
      000DA0 49               [ 1] 2600 	rlc	a
      000DA1 88               [ 1] 2601 	push	a
      000DA2 CDr07r97         [ 4] 2602 	call	_setStat
      000DA5 5B 01            [ 2] 2603 	addw	sp, #1
      000DA7 AE 40 08         [ 2] 2604 	ldw	x, #0x4008
      000DAA F7               [ 1] 2605 	ld	(x), a
                                   2606 ;	clock.c: 434: EEPROM_LOCK();
      000DAB AE 50 5F         [ 2] 2607 	ldw	x, #0x505f
      000DAE F6               [ 1] 2608 	ld	a, (x)
      000DAF A4 F7            [ 1] 2609 	and	a, #0xf7
      000DB1 F7               [ 1] 2610 	ld	(x), a
      000DB2                       2611 00114$:
                                   2612 ;	clock.c: 437: if(Point_Meny == 4){ //Настройка выключение высшего разряда времени "r__4"
      000DB2 CEu00u23         [ 2] 2613 	ldw	x, _Point_Meny+0
      000DB5 A3 00 04         [ 2] 2614 	cpw	x, #0x0004
      000DB8 26 1B            [ 1] 2615 	jrne	00116$
                                   2616 ;	clock.c: 438: EEPROM_UNLOCK();
      000DBA CDr07r71         [ 4] 2617 	call	_EEPROM_UNLOCK
                                   2618 ;	clock.c: 439: EEPROM_DATA(UpLevel) = setStat(EEPROM_DATA(UpLevel)); 
      000DBD AE 40 09         [ 2] 2619 	ldw	x, #0x4009
      000DC0 F6               [ 1] 2620 	ld	a, (x)
      000DC1 40               [ 1] 2621 	neg	a
      000DC2 4F               [ 1] 2622 	clr	a
      000DC3 49               [ 1] 2623 	rlc	a
      000DC4 88               [ 1] 2624 	push	a
      000DC5 CDr07r97         [ 4] 2625 	call	_setStat
      000DC8 5B 01            [ 2] 2626 	addw	sp, #1
      000DCA AE 40 09         [ 2] 2627 	ldw	x, #0x4009
      000DCD F7               [ 1] 2628 	ld	(x), a
                                   2629 ;	clock.c: 440: EEPROM_LOCK();
      000DCE AE 50 5F         [ 2] 2630 	ldw	x, #0x505f
      000DD1 F6               [ 1] 2631 	ld	a, (x)
      000DD2 A4 F7            [ 1] 2632 	and	a, #0xf7
      000DD4 F7               [ 1] 2633 	ld	(x), a
      000DD5                       2634 00116$:
                                   2635 ;	clock.c: 444: if(Point_Meny == 5) clock();
      000DD5 CEu00u23         [ 2] 2636 	ldw	x, _Point_Meny+0
      000DD8 A3 00 05         [ 2] 2637 	cpw	x, #0x0005
      000DDB 26 03            [ 1] 2638 	jrne	00118$
      000DDD CDr0ErE4         [ 4] 2639 	call	_clock
      000DE0                       2640 00118$:
                                   2641 ;	clock.c: 445: if(Point_Meny == 2){
      000DE0 CEu00u23         [ 2] 2642 	ldw	x, _Point_Meny+0
      000DE3 A3 00 02         [ 2] 2643 	cpw	x, #0x0002
      000DE6 26 06            [ 1] 2644 	jrne	00122$
                                   2645 ;	clock.c: 446: Set_Brigh();
      000DE8 CDr0ArA1         [ 4] 2646 	call	_Set_Brigh
                                   2647 ;	clock.c: 447: clock();
      000DEB CDr0ErE4         [ 4] 2648 	call	_clock
      000DEE                       2649 00122$:
                                   2650 ;	clock.c: 453: Soft_Timer++;
      000DEE CEu00u21         [ 2] 2651 	ldw	x, _Soft_Timer+0
      000DF1 5C               [ 2] 2652 	incw	x
                                   2653 ;	clock.c: 454: if(Soft_Timer == 300){
      000DF2 CFu00u21         [ 2] 2654 	ldw	_Soft_Timer+0, x
      000DF5 A3 01 2C         [ 2] 2655 	cpw	x, #0x012c
      000DF8 27 03            [ 1] 2656 	jreq	00205$
      000DFA CCr0Dr10         [ 2] 2657 	jp	00126$
      000DFD                       2658 00205$:
                                   2659 ;	clock.c: 455: TM1637_sendMASS(0x50,0x08,0x08,ASCI[Point_Meny]);
      000DFD AEr00r03         [ 2] 2660 	ldw	x, #_TM1637_seg+0
      000E00 1F 01            [ 2] 2661 	ldw	(0x01, sp), x
      000E02 1E 01            [ 2] 2662 	ldw	x, (0x01, sp)
      000E04 A6 50            [ 1] 2663 	ld	a, #0x50
      000E06 F7               [ 1] 2664 	ld	(x), a
      000E07 1E 01            [ 2] 2665 	ldw	x, (0x01, sp)
      000E09 5C               [ 2] 2666 	incw	x
      000E0A A6 08            [ 1] 2667 	ld	a, #0x08
      000E0C F7               [ 1] 2668 	ld	(x), a
      000E0D 1E 01            [ 2] 2669 	ldw	x, (0x01, sp)
      000E0F 5C               [ 2] 2670 	incw	x
      000E10 5C               [ 2] 2671 	incw	x
      000E11 A6 08            [ 1] 2672 	ld	a, #0x08
      000E13 F7               [ 1] 2673 	ld	(x), a
      000E14 16 01            [ 2] 2674 	ldw	y, (0x01, sp)
      000E16 72 A9 00 03      [ 2] 2675 	addw	y, #0x0003
      000E1A AEr00r07         [ 2] 2676 	ldw	x, #_ASCI+0
      000E1D 72 BBu00u23      [ 2] 2677 	addw	x, _Point_Meny+0
      000E21 F6               [ 1] 2678 	ld	a, (x)
      000E22 90 F7            [ 1] 2679 	ld	(y), a
      000E24 CDr01r39         [ 4] 2680 	call	_TM1637_send
                                   2681 ;	clock.c: 456: Soft_Timer = 0x00;
      000E27 5F               [ 1] 2682 	clrw	x
      000E28 CFu00u21         [ 2] 2683 	ldw	_Soft_Timer+0, x
      000E2B CCr0Dr10         [ 2] 2684 	jp	00126$
      000E2E 5B 02            [ 2] 2685 	addw	sp, #2
      000E30 81               [ 4] 2686 	ret
                                   2687 ;	clock.c: 462: void Meny(){ //Меню
                                   2688 ;	-----------------------------------------
                                   2689 ;	 function Meny
                                   2690 ;	-----------------------------------------
      000E31                       2691 _Meny:
      000E31 52 02            [ 2] 2692 	sub	sp, #2
                                   2693 ;	clock.c: 464: TM1637_cleer();
      000E33 CDr01r80         [ 4] 2694 	call	_TM1637_cleer
                                   2695 ;	clock.c: 465: Point_Meny = 0;
      000E36 5F               [ 1] 2696 	clrw	x
      000E37 CFu00u23         [ 2] 2697 	ldw	_Point_Meny+0, x
                                   2698 ;	clock.c: 466: Soft_Timer = 0x00;
      000E3A 5F               [ 1] 2699 	clrw	x
      000E3B CFu00u21         [ 2] 2700 	ldw	_Soft_Timer+0, x
                                   2701 ;	clock.c: 468: while(1){
      000E3E                       2702 00121$:
                                   2703 ;	clock.c: 470: if(button(up)){
      000E3E 4B 05            [ 1] 2704 	push	#0x05
      000E40 CDr08r75         [ 4] 2705 	call	_button
      000E43 5B 01            [ 2] 2706 	addw	sp, #1
      000E45 4D               [ 1] 2707 	tnz	a
      000E46 27 10            [ 1] 2708 	jreq	00104$
                                   2709 ;	clock.c: 471: Point_Meny++;
      000E48 CEu00u23         [ 2] 2710 	ldw	x, _Point_Meny+0
      000E4B 5C               [ 2] 2711 	incw	x
                                   2712 ;	clock.c: 472: if(Point_Meny > 3)Point_Meny = 0;
      000E4C CFu00u23         [ 2] 2713 	ldw	_Point_Meny+0, x
      000E4F A3 00 03         [ 2] 2714 	cpw	x, #0x0003
      000E52 23 04            [ 2] 2715 	jrule	00104$
      000E54 5F               [ 1] 2716 	clrw	x
      000E55 CFu00u23         [ 2] 2717 	ldw	_Point_Meny+0, x
      000E58                       2718 00104$:
                                   2719 ;	clock.c: 475: if(button(dn)){
      000E58 4B 07            [ 1] 2720 	push	#0x07
      000E5A CDr08r75         [ 4] 2721 	call	_button
      000E5D 5B 01            [ 2] 2722 	addw	sp, #1
      000E5F 4D               [ 1] 2723 	tnz	a
      000E60 27 12            [ 1] 2724 	jreq	00108$
                                   2725 ;	clock.c: 476: Point_Meny--;
      000E62 CEu00u23         [ 2] 2726 	ldw	x, _Point_Meny+0
      000E65 5A               [ 2] 2727 	decw	x
                                   2728 ;	clock.c: 477: if(Point_Meny > 3)Point_Meny = 3;
      000E66 CFu00u23         [ 2] 2729 	ldw	_Point_Meny+0, x
      000E69 A3 00 03         [ 2] 2730 	cpw	x, #0x0003
      000E6C 23 06            [ 2] 2731 	jrule	00108$
      000E6E AE 00 03         [ 2] 2732 	ldw	x, #0x0003
      000E71 CFu00u23         [ 2] 2733 	ldw	_Point_Meny+0, x
      000E74                       2734 00108$:
                                   2735 ;	clock.c: 480: if(button(ok)){
      000E74 4B 06            [ 1] 2736 	push	#0x06
      000E76 CDr08r75         [ 4] 2737 	call	_button
      000E79 5B 01            [ 2] 2738 	addw	sp, #1
      000E7B 4D               [ 1] 2739 	tnz	a
      000E7C 27 26            [ 1] 2740 	jreq	00117$
                                   2741 ;	clock.c: 481: if(Point_Meny == 0)dnClock(); //обратные часы "С__0"
      000E7E CEu00u23         [ 2] 2742 	ldw	x, _Point_Meny+0
      000E81 26 03            [ 1] 2743 	jrne	00110$
      000E83 CDr0FrBA         [ 4] 2744 	call	_dnClock
      000E86                       2745 00110$:
                                   2746 ;	clock.c: 482: if(Point_Meny == 1 || Point_Meny == 3)clock(); //Часы "C__1"
      000E86 CEu00u23         [ 2] 2747 	ldw	x, _Point_Meny+0
      000E89 A3 00 01         [ 2] 2748 	cpw	x, #0x0001
      000E8C 27 08            [ 1] 2749 	jreq	00111$
      000E8E CEu00u23         [ 2] 2750 	ldw	x, _Point_Meny+0
      000E91 A3 00 03         [ 2] 2751 	cpw	x, #0x0003
      000E94 26 03            [ 1] 2752 	jrne	00112$
      000E96                       2753 00111$:
      000E96 CDr0ErE4         [ 4] 2754 	call	_clock
      000E99                       2755 00112$:
                                   2756 ;	clock.c: 483: if(Point_Meny == 2) Set_Meny(); //Настройки "C__2"
      000E99 CEu00u23         [ 2] 2757 	ldw	x, _Point_Meny+0
      000E9C A3 00 02         [ 2] 2758 	cpw	x, #0x0002
      000E9F 26 03            [ 1] 2759 	jrne	00117$
      000EA1 CDr0Dr03         [ 4] 2760 	call	_Set_Meny
      000EA4                       2761 00117$:
                                   2762 ;	clock.c: 488: Soft_Timer++;
      000EA4 CEu00u21         [ 2] 2763 	ldw	x, _Soft_Timer+0
      000EA7 5C               [ 2] 2764 	incw	x
                                   2765 ;	clock.c: 489: if(Soft_Timer == 300){
      000EA8 CFu00u21         [ 2] 2766 	ldw	_Soft_Timer+0, x
      000EAB A3 01 2C         [ 2] 2767 	cpw	x, #0x012c
      000EAE 26 8E            [ 1] 2768 	jrne	00121$
                                   2769 ;	clock.c: 490: TM1637_sendMASS(0x39,0x08,0x08,ASCI[Point_Meny]);
      000EB0 AEr00r03         [ 2] 2770 	ldw	x, #_TM1637_seg+0
      000EB3 1F 01            [ 2] 2771 	ldw	(0x01, sp), x
      000EB5 1E 01            [ 2] 2772 	ldw	x, (0x01, sp)
      000EB7 A6 39            [ 1] 2773 	ld	a, #0x39
      000EB9 F7               [ 1] 2774 	ld	(x), a
      000EBA 1E 01            [ 2] 2775 	ldw	x, (0x01, sp)
      000EBC 5C               [ 2] 2776 	incw	x
      000EBD A6 08            [ 1] 2777 	ld	a, #0x08
      000EBF F7               [ 1] 2778 	ld	(x), a
      000EC0 1E 01            [ 2] 2779 	ldw	x, (0x01, sp)
      000EC2 5C               [ 2] 2780 	incw	x
      000EC3 5C               [ 2] 2781 	incw	x
      000EC4 A6 08            [ 1] 2782 	ld	a, #0x08
      000EC6 F7               [ 1] 2783 	ld	(x), a
      000EC7 16 01            [ 2] 2784 	ldw	y, (0x01, sp)
      000EC9 72 A9 00 03      [ 2] 2785 	addw	y, #0x0003
      000ECD AEr00r07         [ 2] 2786 	ldw	x, #_ASCI+0
      000ED0 72 BBu00u23      [ 2] 2787 	addw	x, _Point_Meny+0
      000ED4 F6               [ 1] 2788 	ld	a, (x)
      000ED5 90 F7            [ 1] 2789 	ld	(y), a
      000ED7 CDr01r39         [ 4] 2790 	call	_TM1637_send
                                   2791 ;	clock.c: 491: Soft_Timer = 0x00;
      000EDA 5F               [ 1] 2792 	clrw	x
      000EDB CFu00u21         [ 2] 2793 	ldw	_Soft_Timer+0, x
      000EDE CCr0Er3E         [ 2] 2794 	jp	00121$
      000EE1 5B 02            [ 2] 2795 	addw	sp, #2
      000EE3 81               [ 4] 2796 	ret
                                   2797 ;	clock.c: 497: void clock(void){
                                   2798 ;	-----------------------------------------
                                   2799 ;	 function clock
                                   2800 ;	-----------------------------------------
      000EE4                       2801 _clock:
      000EE4 52 06            [ 2] 2802 	sub	sp, #6
                                   2803 ;	clock.c: 499: TM1637_cleer();
      000EE6 CDr01r80         [ 4] 2804 	call	_TM1637_cleer
                                   2805 ;	clock.c: 500: Soft_Timer = 0x00; //Сброс таймера
      000EE9 5F               [ 1] 2806 	clrw	x
      000EEA CFu00u21         [ 2] 2807 	ldw	_Soft_Timer+0, x
                                   2808 ;	clock.c: 502: while(1){
      000EED                       2809 00116$:
                                   2810 ;	clock.c: 504: Soft_Timer++;
      000EED CEu00u21         [ 2] 2811 	ldw	x, _Soft_Timer+0
      000EF0 5C               [ 2] 2812 	incw	x
      000EF1 CFu00u21         [ 2] 2813 	ldw	_Soft_Timer+0, x
                                   2814 ;	clock.c: 509: if(button(up))Set_Brigh();
      000EF4 4B 05            [ 1] 2815 	push	#0x05
      000EF6 CDr08r75         [ 4] 2816 	call	_button
      000EF9 5B 01            [ 2] 2817 	addw	sp, #1
      000EFB 4D               [ 1] 2818 	tnz	a
      000EFC 27 03            [ 1] 2819 	jreq	00102$
      000EFE CDr0ArA1         [ 4] 2820 	call	_Set_Brigh
      000F01                       2821 00102$:
                                   2822 ;	clock.c: 510: if(button(dn))Set_Brigh();
      000F01 4B 07            [ 1] 2823 	push	#0x07
      000F03 CDr08r75         [ 4] 2824 	call	_button
      000F06 5B 01            [ 2] 2825 	addw	sp, #1
      000F08 4D               [ 1] 2826 	tnz	a
      000F09 27 03            [ 1] 2827 	jreq	00104$
      000F0B CDr0ArA1         [ 4] 2828 	call	_Set_Brigh
      000F0E                       2829 00104$:
                                   2830 ;	clock.c: 511: if(button(ok))Meny();
      000F0E 4B 06            [ 1] 2831 	push	#0x06
      000F10 CDr08r75         [ 4] 2832 	call	_button
      000F13 5B 01            [ 2] 2833 	addw	sp, #1
      000F15 4D               [ 1] 2834 	tnz	a
      000F16 27 03            [ 1] 2835 	jreq	00106$
      000F18 CDr0Er31         [ 4] 2836 	call	_Meny
      000F1B                       2837 00106$:
                                   2838 ;	clock.c: 513: if(Soft_Timer == 12000){ // Отображение времени при значении Программного таймера
      000F1B CEu00u21         [ 2] 2839 	ldw	x, _Soft_Timer+0
      000F1E A3 2E E0         [ 2] 2840 	cpw	x, #0x2ee0
      000F21 26 CA            [ 1] 2841 	jrne	00116$
                                   2842 ;	clock.c: 514: RTC_Read();
      000F23 CDr04rDE         [ 4] 2843 	call	_RTC_Read
                                   2844 ;	clock.c: 515: dot = !dot;
      000F26 C6u00u07         [ 1] 2845 	ld	a, _dot+0
      000F29 A0 01            [ 1] 2846 	sub	a, #0x01
      000F2B 4F               [ 1] 2847 	clr	a
      000F2C 49               [ 1] 2848 	rlc	a
      000F2D C7u00u07         [ 1] 2849 	ld	_dot+0, a
                                   2850 ;	clock.c: 518: TM1637_seg[0] = ASCI[hour/10];
      000F30 AEr00r03         [ 2] 2851 	ldw	x, #_TM1637_seg+0
      000F33 1F 05            [ 2] 2852 	ldw	(0x05, sp), x
      000F35 AEr00r07         [ 2] 2853 	ldw	x, #_ASCI+0
      000F38 1F 03            [ 2] 2854 	ldw	(0x03, sp), x
      000F3A 5F               [ 1] 2855 	clrw	x
      000F3B C6u00u02         [ 1] 2856 	ld	a, _hour+0
      000F3E 97               [ 1] 2857 	ld	xl, a
      000F3F A6 0A            [ 1] 2858 	ld	a, #0x0a
      000F41 62               [ 2] 2859 	div	x, a
      000F42 4F               [ 1] 2860 	clr	a
      000F43 95               [ 1] 2861 	ld	xh, a
      000F44 72 FB 03         [ 2] 2862 	addw	x, (0x03, sp)
      000F47 F6               [ 1] 2863 	ld	a, (x)
      000F48 1E 05            [ 2] 2864 	ldw	x, (0x05, sp)
      000F4A F7               [ 1] 2865 	ld	(x), a
                                   2866 ;	clock.c: 519: TM1637_seg[1] = ASCI[hour%10];
      000F4B 1E 05            [ 2] 2867 	ldw	x, (0x05, sp)
      000F4D 5C               [ 2] 2868 	incw	x
      000F4E 1F 01            [ 2] 2869 	ldw	(0x01, sp), x
      000F50 5F               [ 1] 2870 	clrw	x
      000F51 C6u00u02         [ 1] 2871 	ld	a, _hour+0
      000F54 97               [ 1] 2872 	ld	xl, a
      000F55 A6 0A            [ 1] 2873 	ld	a, #0x0a
      000F57 62               [ 2] 2874 	div	x, a
      000F58 5F               [ 1] 2875 	clrw	x
      000F59 97               [ 1] 2876 	ld	xl, a
      000F5A 72 FB 03         [ 2] 2877 	addw	x, (0x03, sp)
      000F5D F6               [ 1] 2878 	ld	a, (x)
      000F5E 1E 01            [ 2] 2879 	ldw	x, (0x01, sp)
      000F60 F7               [ 1] 2880 	ld	(x), a
                                   2881 ;	clock.c: 520: TM1637_seg[2] = ASCI[min/10];
      000F61 16 05            [ 2] 2882 	ldw	y, (0x05, sp)
      000F63 72 A9 00 02      [ 2] 2883 	addw	y, #0x0002
      000F67 5F               [ 1] 2884 	clrw	x
      000F68 C6u00u01         [ 1] 2885 	ld	a, _min+0
      000F6B 97               [ 1] 2886 	ld	xl, a
      000F6C A6 0A            [ 1] 2887 	ld	a, #0x0a
      000F6E 62               [ 2] 2888 	div	x, a
      000F6F 4F               [ 1] 2889 	clr	a
      000F70 95               [ 1] 2890 	ld	xh, a
      000F71 72 FB 03         [ 2] 2891 	addw	x, (0x03, sp)
      000F74 F6               [ 1] 2892 	ld	a, (x)
      000F75 90 F7            [ 1] 2893 	ld	(y), a
                                   2894 ;	clock.c: 521: TM1637_seg[3] = ASCI[min%10];
      000F77 16 05            [ 2] 2895 	ldw	y, (0x05, sp)
      000F79 72 A9 00 03      [ 2] 2896 	addw	y, #0x0003
      000F7D 5F               [ 1] 2897 	clrw	x
      000F7E C6u00u01         [ 1] 2898 	ld	a, _min+0
      000F81 97               [ 1] 2899 	ld	xl, a
      000F82 A6 0A            [ 1] 2900 	ld	a, #0x0a
      000F84 62               [ 2] 2901 	div	x, a
      000F85 5F               [ 1] 2902 	clrw	x
      000F86 97               [ 1] 2903 	ld	xl, a
      000F87 72 FB 03         [ 2] 2904 	addw	x, (0x03, sp)
      000F8A F6               [ 1] 2905 	ld	a, (x)
      000F8B 90 F7            [ 1] 2906 	ld	(y), a
                                   2907 ;	clock.c: 523: if(EEPROM_DATA(UpLevel))if(hour<10)	TM1637_seg[0] =  0x00; //Отключение первого разряда если в нем 0
      000F8D AE 40 09         [ 2] 2908 	ldw	x, #0x4009
      000F90 F6               [ 1] 2909 	ld	a, (x)
      000F91 4D               [ 1] 2910 	tnz	a
      000F92 27 0A            [ 1] 2911 	jreq	00110$
      000F94 C6u00u02         [ 1] 2912 	ld	a, _hour+0
      000F97 A1 0A            [ 1] 2913 	cp	a, #0x0a
      000F99 24 03            [ 1] 2914 	jrnc	00110$
      000F9B 1E 05            [ 2] 2915 	ldw	x, (0x05, sp)
      000F9D 7F               [ 1] 2916 	clr	(x)
      000F9E                       2917 00110$:
                                   2918 ;	clock.c: 524: if(dot) TM1637_seg[1] = TM1637_seg[1] + 0x80; //Включение секундных точек
      000F9E 72 00u00u07 02   [ 2] 2919 	btjt	_dot+0, #0, 00160$
      000FA3 20 08            [ 2] 2920 	jra	00112$
      000FA5                       2921 00160$:
      000FA5 1E 01            [ 2] 2922 	ldw	x, (0x01, sp)
      000FA7 F6               [ 1] 2923 	ld	a, (x)
      000FA8 AB 80            [ 1] 2924 	add	a, #0x80
      000FAA 1E 01            [ 2] 2925 	ldw	x, (0x01, sp)
      000FAC F7               [ 1] 2926 	ld	(x), a
      000FAD                       2927 00112$:
                                   2928 ;	clock.c: 526: TM1637_send();
      000FAD CDr01r39         [ 4] 2929 	call	_TM1637_send
                                   2930 ;	clock.c: 527: Soft_Timer = 0x00; //Сброс таймера
      000FB0 5F               [ 1] 2931 	clrw	x
      000FB1 CFu00u21         [ 2] 2932 	ldw	_Soft_Timer+0, x
      000FB4 CCr0ErED         [ 2] 2933 	jp	00116$
      000FB7 5B 06            [ 2] 2934 	addw	sp, #6
      000FB9 81               [ 4] 2935 	ret
                                   2936 ;	clock.c: 535: void dnClock(void){
                                   2937 ;	-----------------------------------------
                                   2938 ;	 function dnClock
                                   2939 ;	-----------------------------------------
      000FBA                       2940 _dnClock:
      000FBA 52 42            [ 2] 2941 	sub	sp, #66
                                   2942 ;	clock.c: 537: TM1637_cleer();
      000FBC CDr01r80         [ 4] 2943 	call	_TM1637_cleer
                                   2944 ;	clock.c: 538: Soft_Timer = 0x00; //Сброс таймера
      000FBF 5F               [ 1] 2945 	clrw	x
      000FC0 CFu00u21         [ 2] 2946 	ldw	_Soft_Timer+0, x
                                   2947 ;	clock.c: 539: PointTimer = 0;
      000FC3 72 5Fu00u22      [ 1] 2948 	clr	_PointTimer+0
                                   2949 ;	clock.c: 541: DnClock_Tim_0 = transTime(0,EEPROM_DATA(DnClock_hour_0),EEPROM_DATA(DnClock_min_0),0);
      000FC7 AE 40 01         [ 2] 2950 	ldw	x, #0x4001
      000FCA F6               [ 1] 2951 	ld	a, (x)
      000FCB 97               [ 1] 2952 	ld	xl, a
      000FCC 49               [ 1] 2953 	rlc	a
      000FCD 4F               [ 1] 2954 	clr	a
      000FCE A2 00            [ 1] 2955 	sbc	a, #0x00
      000FD0 95               [ 1] 2956 	ld	xh, a
      000FD1 6B 35            [ 1] 2957 	ld	(0x35, sp), a
      000FD3 6B 34            [ 1] 2958 	ld	(0x34, sp), a
      000FD5 90 AE 40 00      [ 2] 2959 	ldw	y, #0x4000
      000FD9 90 F6            [ 1] 2960 	ld	a, (y)
      000FDB 6B 2D            [ 1] 2961 	ld	(0x2d, sp), a
      000FDD 7B 2D            [ 1] 2962 	ld	a, (0x2d, sp)
      000FDF 49               [ 1] 2963 	rlc	a
      000FE0 4F               [ 1] 2964 	clr	a
      000FE1 A2 00            [ 1] 2965 	sbc	a, #0x00
      000FE3 6B 2C            [ 1] 2966 	ld	(0x2c, sp), a
      000FE5 90 97            [ 1] 2967 	ld	yl, a
      000FE7 90 95            [ 1] 2968 	ld	yh, a
      000FE9 4B 00            [ 1] 2969 	push	#0x00
      000FEB 4B 00            [ 1] 2970 	push	#0x00
      000FED 4B 00            [ 1] 2971 	push	#0x00
      000FEF 4B 00            [ 1] 2972 	push	#0x00
      000FF1 89               [ 2] 2973 	pushw	x
      000FF2 1E 3A            [ 2] 2974 	ldw	x, (0x3a, sp)
      000FF4 89               [ 2] 2975 	pushw	x
      000FF5 1E 34            [ 2] 2976 	ldw	x, (0x34, sp)
      000FF7 89               [ 2] 2977 	pushw	x
      000FF8 90 89            [ 2] 2978 	pushw	y
      000FFA 5F               [ 1] 2979 	clrw	x
      000FFB 89               [ 2] 2980 	pushw	x
      000FFC 5F               [ 1] 2981 	clrw	x
      000FFD 89               [ 2] 2982 	pushw	x
      000FFE CDr07r15         [ 4] 2983 	call	_transTime
      001001 5B 10            [ 2] 2984 	addw	sp, #16
      001003 CFu00u0C         [ 2] 2985 	ldw	_DnClock_Tim_0+2, x
      001006 90 CFu00u0A      [ 2] 2986 	ldw	_DnClock_Tim_0+0, y
                                   2987 ;	clock.c: 542: DnClock_Tim_1 = transTime(0,EEPROM_DATA(DnClock_hour_1),EEPROM_DATA(DnClock_min_1),0);
      00100A AE 40 03         [ 2] 2988 	ldw	x, #0x4003
      00100D F6               [ 1] 2989 	ld	a, (x)
      00100E 97               [ 1] 2990 	ld	xl, a
      00100F 49               [ 1] 2991 	rlc	a
      001010 4F               [ 1] 2992 	clr	a
      001011 A2 00            [ 1] 2993 	sbc	a, #0x00
      001013 95               [ 1] 2994 	ld	xh, a
      001014 6B 0A            [ 1] 2995 	ld	(0x0a, sp), a
      001016 6B 09            [ 1] 2996 	ld	(0x09, sp), a
      001018 90 AE 40 02      [ 2] 2997 	ldw	y, #0x4002
      00101C 90 F6            [ 1] 2998 	ld	a, (y)
      00101E 6B 41            [ 1] 2999 	ld	(0x41, sp), a
      001020 7B 41            [ 1] 3000 	ld	a, (0x41, sp)
      001022 49               [ 1] 3001 	rlc	a
      001023 4F               [ 1] 3002 	clr	a
      001024 A2 00            [ 1] 3003 	sbc	a, #0x00
      001026 6B 40            [ 1] 3004 	ld	(0x40, sp), a
      001028 90 97            [ 1] 3005 	ld	yl, a
      00102A 90 95            [ 1] 3006 	ld	yh, a
      00102C 4B 00            [ 1] 3007 	push	#0x00
      00102E 4B 00            [ 1] 3008 	push	#0x00
      001030 4B 00            [ 1] 3009 	push	#0x00
      001032 4B 00            [ 1] 3010 	push	#0x00
      001034 89               [ 2] 3011 	pushw	x
      001035 1E 0F            [ 2] 3012 	ldw	x, (0x0f, sp)
      001037 89               [ 2] 3013 	pushw	x
      001038 1E 48            [ 2] 3014 	ldw	x, (0x48, sp)
      00103A 89               [ 2] 3015 	pushw	x
      00103B 90 89            [ 2] 3016 	pushw	y
      00103D 5F               [ 1] 3017 	clrw	x
      00103E 89               [ 2] 3018 	pushw	x
      00103F 5F               [ 1] 3019 	clrw	x
      001040 89               [ 2] 3020 	pushw	x
      001041 CDr07r15         [ 4] 3021 	call	_transTime
      001044 5B 10            [ 2] 3022 	addw	sp, #16
      001046 CFu00u10         [ 2] 3023 	ldw	_DnClock_Tim_1+2, x
      001049 90 CFu00u0E      [ 2] 3024 	ldw	_DnClock_Tim_1+0, y
                                   3025 ;	clock.c: 543: DnClock_Tim_2 = transTime(0,EEPROM_DATA(DnClock_hour_2),EEPROM_DATA(DnClock_min_2),0);
      00104D AE 40 05         [ 2] 3026 	ldw	x, #0x4005
      001050 F6               [ 1] 3027 	ld	a, (x)
      001051 97               [ 1] 3028 	ld	xl, a
      001052 49               [ 1] 3029 	rlc	a
      001053 4F               [ 1] 3030 	clr	a
      001054 A2 00            [ 1] 3031 	sbc	a, #0x00
      001056 95               [ 1] 3032 	ld	xh, a
      001057 6B 27            [ 1] 3033 	ld	(0x27, sp), a
      001059 6B 26            [ 1] 3034 	ld	(0x26, sp), a
      00105B 90 AE 40 04      [ 2] 3035 	ldw	y, #0x4004
      00105F 90 F6            [ 1] 3036 	ld	a, (y)
      001061 6B 06            [ 1] 3037 	ld	(0x06, sp), a
      001063 7B 06            [ 1] 3038 	ld	a, (0x06, sp)
      001065 49               [ 1] 3039 	rlc	a
      001066 4F               [ 1] 3040 	clr	a
      001067 A2 00            [ 1] 3041 	sbc	a, #0x00
      001069 6B 05            [ 1] 3042 	ld	(0x05, sp), a
      00106B 90 97            [ 1] 3043 	ld	yl, a
      00106D 90 95            [ 1] 3044 	ld	yh, a
      00106F 4B 00            [ 1] 3045 	push	#0x00
      001071 4B 00            [ 1] 3046 	push	#0x00
      001073 4B 00            [ 1] 3047 	push	#0x00
      001075 4B 00            [ 1] 3048 	push	#0x00
      001077 89               [ 2] 3049 	pushw	x
      001078 1E 2C            [ 2] 3050 	ldw	x, (0x2c, sp)
      00107A 89               [ 2] 3051 	pushw	x
      00107B 1E 0D            [ 2] 3052 	ldw	x, (0x0d, sp)
      00107D 89               [ 2] 3053 	pushw	x
      00107E 90 89            [ 2] 3054 	pushw	y
      001080 5F               [ 1] 3055 	clrw	x
      001081 89               [ 2] 3056 	pushw	x
      001082 5F               [ 1] 3057 	clrw	x
      001083 89               [ 2] 3058 	pushw	x
      001084 CDr07r15         [ 4] 3059 	call	_transTime
      001087 5B 10            [ 2] 3060 	addw	sp, #16
      001089 CFu00u14         [ 2] 3061 	ldw	_DnClock_Tim_2+2, x
      00108C 90 CFu00u12      [ 2] 3062 	ldw	_DnClock_Tim_2+0, y
                                   3063 ;	clock.c: 544: DnClock_Tim_3 = transTime(0,EEPROM_DATA(DnClock_hour_3),EEPROM_DATA(DnClock_min_3),0);
      001090 AE 40 07         [ 2] 3064 	ldw	x, #0x4007
      001093 F6               [ 1] 3065 	ld	a, (x)
      001094 97               [ 1] 3066 	ld	xl, a
      001095 49               [ 1] 3067 	rlc	a
      001096 4F               [ 1] 3068 	clr	a
      001097 A2 00            [ 1] 3069 	sbc	a, #0x00
      001099 95               [ 1] 3070 	ld	xh, a
      00109A 6B 0E            [ 1] 3071 	ld	(0x0e, sp), a
      00109C 6B 0D            [ 1] 3072 	ld	(0x0d, sp), a
      00109E 90 AE 40 06      [ 2] 3073 	ldw	y, #0x4006
      0010A2 90 F6            [ 1] 3074 	ld	a, (y)
      0010A4 6B 22            [ 1] 3075 	ld	(0x22, sp), a
      0010A6 7B 22            [ 1] 3076 	ld	a, (0x22, sp)
      0010A8 49               [ 1] 3077 	rlc	a
      0010A9 4F               [ 1] 3078 	clr	a
      0010AA A2 00            [ 1] 3079 	sbc	a, #0x00
      0010AC 6B 21            [ 1] 3080 	ld	(0x21, sp), a
      0010AE 90 97            [ 1] 3081 	ld	yl, a
      0010B0 90 95            [ 1] 3082 	ld	yh, a
      0010B2 4B 00            [ 1] 3083 	push	#0x00
      0010B4 4B 00            [ 1] 3084 	push	#0x00
      0010B6 4B 00            [ 1] 3085 	push	#0x00
      0010B8 4B 00            [ 1] 3086 	push	#0x00
      0010BA 89               [ 2] 3087 	pushw	x
      0010BB 1E 13            [ 2] 3088 	ldw	x, (0x13, sp)
      0010BD 89               [ 2] 3089 	pushw	x
      0010BE 1E 29            [ 2] 3090 	ldw	x, (0x29, sp)
      0010C0 89               [ 2] 3091 	pushw	x
      0010C1 90 89            [ 2] 3092 	pushw	y
      0010C3 5F               [ 1] 3093 	clrw	x
      0010C4 89               [ 2] 3094 	pushw	x
      0010C5 5F               [ 1] 3095 	clrw	x
      0010C6 89               [ 2] 3096 	pushw	x
      0010C7 CDr07r15         [ 4] 3097 	call	_transTime
      0010CA 5B 10            [ 2] 3098 	addw	sp, #16
      0010CC CFu00u18         [ 2] 3099 	ldw	_DnClock_Tim_3+2, x
      0010CF 90 CFu00u16      [ 2] 3100 	ldw	_DnClock_Tim_3+0, y
                                   3101 ;	clock.c: 546: while(1){
      0010D3                       3102 00128$:
                                   3103 ;	clock.c: 548: Soft_Timer++;
      0010D3 CEu00u21         [ 2] 3104 	ldw	x, _Soft_Timer+0
      0010D6 5C               [ 2] 3105 	incw	x
      0010D7 CFu00u21         [ 2] 3106 	ldw	_Soft_Timer+0, x
                                   3107 ;	clock.c: 550: if(button(ok))Meny();
      0010DA 4B 06            [ 1] 3108 	push	#0x06
      0010DC CDr08r75         [ 4] 3109 	call	_button
      0010DF 5B 01            [ 2] 3110 	addw	sp, #1
      0010E1 4D               [ 1] 3111 	tnz	a
      0010E2 27 03            [ 1] 3112 	jreq	00102$
      0010E4 CDr0Er31         [ 4] 3113 	call	_Meny
      0010E7                       3114 00102$:
                                   3115 ;	clock.c: 552: if(button(up)){
      0010E7 4B 05            [ 1] 3116 	push	#0x05
      0010E9 CDr08r75         [ 4] 3117 	call	_button
      0010EC 5B 01            [ 2] 3118 	addw	sp, #1
      0010EE 6B 19            [ 1] 3119 	ld	(0x19, sp), a
      0010F0 0D 19            [ 1] 3120 	tnz	(0x19, sp)
      0010F2 27 39            [ 1] 3121 	jreq	00104$
                                   3122 ;	clock.c: 553: TM1637_sendMASS(0x78,0x50,0x08,ASCI[PointTimer]);
      0010F4 AEr00r03         [ 2] 3123 	ldw	x, #_TM1637_seg+0
      0010F7 1F 01            [ 2] 3124 	ldw	(0x01, sp), x
      0010F9 1E 01            [ 2] 3125 	ldw	x, (0x01, sp)
      0010FB A6 78            [ 1] 3126 	ld	a, #0x78
      0010FD F7               [ 1] 3127 	ld	(x), a
      0010FE 1E 01            [ 2] 3128 	ldw	x, (0x01, sp)
      001100 5C               [ 2] 3129 	incw	x
      001101 A6 50            [ 1] 3130 	ld	a, #0x50
      001103 F7               [ 1] 3131 	ld	(x), a
      001104 1E 01            [ 2] 3132 	ldw	x, (0x01, sp)
      001106 5C               [ 2] 3133 	incw	x
      001107 5C               [ 2] 3134 	incw	x
      001108 A6 08            [ 1] 3135 	ld	a, #0x08
      00110A F7               [ 1] 3136 	ld	(x), a
      00110B 16 01            [ 2] 3137 	ldw	y, (0x01, sp)
      00110D 72 A9 00 03      [ 2] 3138 	addw	y, #0x0003
      001111 AEr00r07         [ 2] 3139 	ldw	x, #_ASCI+0
      001114 9F               [ 1] 3140 	ld	a, xl
      001115 CBu00u22         [ 1] 3141 	add	a, _PointTimer+0
      001118 02               [ 1] 3142 	rlwa	x
      001119 A9 00            [ 1] 3143 	adc	a, #0x00
      00111B 95               [ 1] 3144 	ld	xh, a
      00111C F6               [ 1] 3145 	ld	a, (x)
      00111D 90 F7            [ 1] 3146 	ld	(y), a
      00111F CDr01r39         [ 4] 3147 	call	_TM1637_send
                                   3148 ;	clock.c: 554: delay(9000);
      001122 4B 28            [ 1] 3149 	push	#0x28
      001124 4B 23            [ 1] 3150 	push	#0x23
      001126 5F               [ 1] 3151 	clrw	x
      001127 89               [ 2] 3152 	pushw	x
      001128 CDr00r00         [ 4] 3153 	call	_delay
      00112B 5B 04            [ 2] 3154 	addw	sp, #4
      00112D                       3155 00104$:
                                   3156 ;	clock.c: 558: if(Soft_Timer == 15000){ // Отображение времени при значении Программного таймера
      00112D CEu00u21         [ 2] 3157 	ldw	x, _Soft_Timer+0
      001130 A3 3A 98         [ 2] 3158 	cpw	x, #0x3a98
      001133 26 9E            [ 1] 3159 	jrne	00128$
                                   3160 ;	clock.c: 559: RTC_Read();
      001135 CDr04rDE         [ 4] 3161 	call	_RTC_Read
                                   3162 ;	clock.c: 562: timeToSec = transTime(0,hour,min,sec);
      001138 5F               [ 1] 3163 	clrw	x
      001139 C6u00u00         [ 1] 3164 	ld	a, _sec+0
      00113C 97               [ 1] 3165 	ld	xl, a
      00113D 0F 31            [ 1] 3166 	clr	(0x31, sp)
      00113F 0F 30            [ 1] 3167 	clr	(0x30, sp)
      001141 C6u00u01         [ 1] 3168 	ld	a, _min+0
      001144 6B 18            [ 1] 3169 	ld	(0x18, sp), a
      001146 0F 17            [ 1] 3170 	clr	(0x17, sp)
      001148 90 5F            [ 1] 3171 	clrw	y
      00114A C6u00u02         [ 1] 3172 	ld	a, _hour+0
      00114D 6B 3B            [ 1] 3173 	ld	(0x3b, sp), a
      00114F 0F 3A            [ 1] 3174 	clr	(0x3a, sp)
      001151 0F 39            [ 1] 3175 	clr	(0x39, sp)
      001153 0F 38            [ 1] 3176 	clr	(0x38, sp)
      001155 89               [ 2] 3177 	pushw	x
      001156 1E 32            [ 2] 3178 	ldw	x, (0x32, sp)
      001158 89               [ 2] 3179 	pushw	x
      001159 1E 1B            [ 2] 3180 	ldw	x, (0x1b, sp)
      00115B 89               [ 2] 3181 	pushw	x
      00115C 90 89            [ 2] 3182 	pushw	y
      00115E 1E 42            [ 2] 3183 	ldw	x, (0x42, sp)
      001160 89               [ 2] 3184 	pushw	x
      001161 1E 42            [ 2] 3185 	ldw	x, (0x42, sp)
      001163 89               [ 2] 3186 	pushw	x
      001164 5F               [ 1] 3187 	clrw	x
      001165 89               [ 2] 3188 	pushw	x
      001166 5F               [ 1] 3189 	clrw	x
      001167 89               [ 2] 3190 	pushw	x
      001168 CDr07r15         [ 4] 3191 	call	_transTime
      00116B 5B 10            [ 2] 3192 	addw	sp, #16
      00116D CFu00u1C         [ 2] 3193 	ldw	_timeToSec+2, x
      001170 90 CFu00u1A      [ 2] 3194 	ldw	_timeToSec+0, y
                                   3195 ;	clock.c: 563: dot = !dot;
      001174 C6u00u07         [ 1] 3196 	ld	a, _dot+0
      001177 A0 01            [ 1] 3197 	sub	a, #0x01
      001179 4F               [ 1] 3198 	clr	a
      00117A 49               [ 1] 3199 	rlc	a
      00117B C7u00u07         [ 1] 3200 	ld	_dot+0, a
                                   3201 ;	clock.c: 564: PointTimer = 0x00;
      00117E 72 5Fu00u22      [ 1] 3202 	clr	_PointTimer+0
                                   3203 ;	clock.c: 567: if( timeToSec+1 > DnClock_Tim_0 & timeToSec < DnClock_Tim_1) PointTimer = 1; //От начало смены до начало обеда
      001182 CEu00u1C         [ 2] 3204 	ldw	x, _timeToSec+2
      001185 1C 00 01         [ 2] 3205 	addw	x, #0x0001
      001188 1F 1D            [ 2] 3206 	ldw	(0x1d, sp), x
      00118A C6u00u1B         [ 1] 3207 	ld	a, _timeToSec+1
      00118D A9 00            [ 1] 3208 	adc	a, #0x00
      00118F 6B 1C            [ 1] 3209 	ld	(0x1c, sp), a
      001191 C6u00u1A         [ 1] 3210 	ld	a, _timeToSec+0
      001194 A9 00            [ 1] 3211 	adc	a, #0x00
      001196 6B 1B            [ 1] 3212 	ld	(0x1b, sp), a
      001198 CEu00u0C         [ 2] 3213 	ldw	x, _DnClock_Tim_0+2
      00119B 13 1D            [ 2] 3214 	cpw	x, (0x1d, sp)
      00119D C6u00u0B         [ 1] 3215 	ld	a, _DnClock_Tim_0+1
      0011A0 12 1C            [ 1] 3216 	sbc	a, (0x1c, sp)
      0011A2 C6u00u0A         [ 1] 3217 	ld	a, _DnClock_Tim_0+0
      0011A5 12 1B            [ 1] 3218 	sbc	a, (0x1b, sp)
      0011A7 25 04            [ 1] 3219 	jrc	00193$
      0011A9 0F 1A            [ 1] 3220 	clr	(0x1a, sp)
      0011AB 20 04            [ 2] 3221 	jra	00194$
      0011AD                       3222 00193$:
      0011AD A6 01            [ 1] 3223 	ld	a, #0x01
      0011AF 6B 1A            [ 1] 3224 	ld	(0x1a, sp), a
      0011B1                       3225 00194$:
      0011B1 CEu00u1C         [ 2] 3226 	ldw	x, _timeToSec+2
      0011B4 C3u00u10         [ 2] 3227 	cpw	x, _DnClock_Tim_1+2
      0011B7 C6u00u1B         [ 1] 3228 	ld	a, _timeToSec+1
      0011BA C2u00u0F         [ 1] 3229 	sbc	a, _DnClock_Tim_1+1
      0011BD C6u00u1A         [ 1] 3230 	ld	a, _timeToSec+0
      0011C0 C2u00u0E         [ 1] 3231 	sbc	a, _DnClock_Tim_1+0
      0011C3 25 03            [ 1] 3232 	jrc	00195$
      0011C5 4F               [ 1] 3233 	clr	a
      0011C6 20 02            [ 2] 3234 	jra	00196$
      0011C8                       3235 00195$:
      0011C8 A6 01            [ 1] 3236 	ld	a, #0x01
      0011CA                       3237 00196$:
      0011CA 14 1A            [ 1] 3238 	and	a, (0x1a, sp)
      0011CC 4D               [ 1] 3239 	tnz	a
      0011CD 27 04            [ 1] 3240 	jreq	00106$
      0011CF 35 01u00u22      [ 1] 3241 	mov	_PointTimer+0, #0x01
      0011D3                       3242 00106$:
                                   3243 ;	clock.c: 569: if( timeToSec+1 > DnClock_Tim_1 & timeToSec < DnClock_Tim_2) PointTimer = 2; //от начала обеда до  конца обеда;
      0011D3 CEu00u10         [ 2] 3244 	ldw	x, _DnClock_Tim_1+2
      0011D6 13 1D            [ 2] 3245 	cpw	x, (0x1d, sp)
      0011D8 C6u00u0F         [ 1] 3246 	ld	a, _DnClock_Tim_1+1
      0011DB 12 1C            [ 1] 3247 	sbc	a, (0x1c, sp)
      0011DD C6u00u0E         [ 1] 3248 	ld	a, _DnClock_Tim_1+0
      0011E0 12 1B            [ 1] 3249 	sbc	a, (0x1b, sp)
      0011E2 25 04            [ 1] 3250 	jrc	00198$
      0011E4 0F 23            [ 1] 3251 	clr	(0x23, sp)
      0011E6 20 04            [ 2] 3252 	jra	00199$
      0011E8                       3253 00198$:
      0011E8 A6 01            [ 1] 3254 	ld	a, #0x01
      0011EA 6B 23            [ 1] 3255 	ld	(0x23, sp), a
      0011EC                       3256 00199$:
      0011EC CEu00u1C         [ 2] 3257 	ldw	x, _timeToSec+2
      0011EF C3u00u14         [ 2] 3258 	cpw	x, _DnClock_Tim_2+2
      0011F2 C6u00u1B         [ 1] 3259 	ld	a, _timeToSec+1
      0011F5 C2u00u13         [ 1] 3260 	sbc	a, _DnClock_Tim_2+1
      0011F8 C6u00u1A         [ 1] 3261 	ld	a, _timeToSec+0
      0011FB C2u00u12         [ 1] 3262 	sbc	a, _DnClock_Tim_2+0
      0011FE 25 03            [ 1] 3263 	jrc	00200$
      001200 4F               [ 1] 3264 	clr	a
      001201 20 02            [ 2] 3265 	jra	00201$
      001203                       3266 00200$:
      001203 A6 01            [ 1] 3267 	ld	a, #0x01
      001205                       3268 00201$:
      001205 14 23            [ 1] 3269 	and	a, (0x23, sp)
      001207 4D               [ 1] 3270 	tnz	a
      001208 27 04            [ 1] 3271 	jreq	00108$
      00120A 35 02u00u22      [ 1] 3272 	mov	_PointTimer+0, #0x02
      00120E                       3273 00108$:
                                   3274 ;	clock.c: 571: if( timeToSec+1 > DnClock_Tim_2 & timeToSec < DnClock_Tim_3) PointTimer = 3; //от конца  обеда до  конца смены
      00120E CEu00u14         [ 2] 3275 	ldw	x, _DnClock_Tim_2+2
      001211 13 1D            [ 2] 3276 	cpw	x, (0x1d, sp)
      001213 C6u00u13         [ 1] 3277 	ld	a, _DnClock_Tim_2+1
      001216 12 1C            [ 1] 3278 	sbc	a, (0x1c, sp)
      001218 C6u00u12         [ 1] 3279 	ld	a, _DnClock_Tim_2+0
      00121B 12 1B            [ 1] 3280 	sbc	a, (0x1b, sp)
      00121D 25 04            [ 1] 3281 	jrc	00203$
      00121F 0F 42            [ 1] 3282 	clr	(0x42, sp)
      001221 20 04            [ 2] 3283 	jra	00204$
      001223                       3284 00203$:
      001223 A6 01            [ 1] 3285 	ld	a, #0x01
      001225 6B 42            [ 1] 3286 	ld	(0x42, sp), a
      001227                       3287 00204$:
      001227 CEu00u1C         [ 2] 3288 	ldw	x, _timeToSec+2
      00122A C3u00u18         [ 2] 3289 	cpw	x, _DnClock_Tim_3+2
      00122D C6u00u1B         [ 1] 3290 	ld	a, _timeToSec+1
      001230 C2u00u17         [ 1] 3291 	sbc	a, _DnClock_Tim_3+1
      001233 C6u00u1A         [ 1] 3292 	ld	a, _timeToSec+0
      001236 C2u00u16         [ 1] 3293 	sbc	a, _DnClock_Tim_3+0
      001239 25 03            [ 1] 3294 	jrc	00205$
      00123B 4F               [ 1] 3295 	clr	a
      00123C 20 02            [ 2] 3296 	jra	00206$
      00123E                       3297 00205$:
      00123E A6 01            [ 1] 3298 	ld	a, #0x01
      001240                       3299 00206$:
      001240 14 42            [ 1] 3300 	and	a, (0x42, sp)
      001242 4D               [ 1] 3301 	tnz	a
      001243 27 04            [ 1] 3302 	jreq	00110$
      001245 35 03u00u22      [ 1] 3303 	mov	_PointTimer+0, #0x03
      001249                       3304 00110$:
                                   3305 ;	clock.c: 574: switch (PointTimer) {
      001249 C6u00u22         [ 1] 3306 	ld	a, _PointTimer+0
      00124C A1 01            [ 1] 3307 	cp	a, #0x01
      00124E 27 10            [ 1] 3308 	jreq	00111$
      001250 C6u00u22         [ 1] 3309 	ld	a, _PointTimer+0
      001253 A1 02            [ 1] 3310 	cp	a, #0x02
      001255 27 28            [ 1] 3311 	jreq	00112$
      001257 C6u00u22         [ 1] 3312 	ld	a, _PointTimer+0
      00125A A1 03            [ 1] 3313 	cp	a, #0x03
      00125C 27 40            [ 1] 3314 	jreq	00113$
      00125E 20 5D            [ 2] 3315 	jra	00114$
                                   3316 ;	clock.c: 575: case 1: timeRes = DnClock_Tim_1 - timeToSec; break;
      001260                       3317 00111$:
      001260 90 CEu00u10      [ 2] 3318 	ldw	y, _DnClock_Tim_1+2
      001264 72 B2u00u1C      [ 2] 3319 	subw	y, _timeToSec+2
      001268 C6u00u0F         [ 1] 3320 	ld	a, _DnClock_Tim_1+1
      00126B C2u00u1B         [ 1] 3321 	sbc	a, _timeToSec+1
      00126E 97               [ 1] 3322 	ld	xl, a
      00126F C6u00u0E         [ 1] 3323 	ld	a, _DnClock_Tim_1+0
      001272 C2u00u1A         [ 1] 3324 	sbc	a, _timeToSec+0
      001275 95               [ 1] 3325 	ld	xh, a
      001276 90 CFu00u20      [ 2] 3326 	ldw	_timeRes+2, y
      00127A CFu00u1E         [ 2] 3327 	ldw	_timeRes+0, x
      00127D 20 45            [ 2] 3328 	jra	00115$
                                   3329 ;	clock.c: 576: case 2: timeRes = DnClock_Tim_2 - timeToSec; break;
      00127F                       3330 00112$:
      00127F 90 CEu00u14      [ 2] 3331 	ldw	y, _DnClock_Tim_2+2
      001283 72 B2u00u1C      [ 2] 3332 	subw	y, _timeToSec+2
      001287 C6u00u13         [ 1] 3333 	ld	a, _DnClock_Tim_2+1
      00128A C2u00u1B         [ 1] 3334 	sbc	a, _timeToSec+1
      00128D 97               [ 1] 3335 	ld	xl, a
      00128E C6u00u12         [ 1] 3336 	ld	a, _DnClock_Tim_2+0
      001291 C2u00u1A         [ 1] 3337 	sbc	a, _timeToSec+0
      001294 95               [ 1] 3338 	ld	xh, a
      001295 90 CFu00u20      [ 2] 3339 	ldw	_timeRes+2, y
      001299 CFu00u1E         [ 2] 3340 	ldw	_timeRes+0, x
      00129C 20 26            [ 2] 3341 	jra	00115$
                                   3342 ;	clock.c: 577: case 3: timeRes = DnClock_Tim_3 - timeToSec; break;
      00129E                       3343 00113$:
      00129E 90 CEu00u18      [ 2] 3344 	ldw	y, _DnClock_Tim_3+2
      0012A2 72 B2u00u1C      [ 2] 3345 	subw	y, _timeToSec+2
      0012A6 C6u00u17         [ 1] 3346 	ld	a, _DnClock_Tim_3+1
      0012A9 C2u00u1B         [ 1] 3347 	sbc	a, _timeToSec+1
      0012AC 97               [ 1] 3348 	ld	xl, a
      0012AD C6u00u16         [ 1] 3349 	ld	a, _DnClock_Tim_3+0
      0012B0 C2u00u1A         [ 1] 3350 	sbc	a, _timeToSec+0
      0012B3 95               [ 1] 3351 	ld	xh, a
      0012B4 90 CFu00u20      [ 2] 3352 	ldw	_timeRes+2, y
      0012B8 CFu00u1E         [ 2] 3353 	ldw	_timeRes+0, x
      0012BB 20 07            [ 2] 3354 	jra	00115$
                                   3355 ;	clock.c: 579: default: timeRes = 0; break;
      0012BD                       3356 00114$:
      0012BD 5F               [ 1] 3357 	clrw	x
      0012BE CFu00u20         [ 2] 3358 	ldw	_timeRes+2, x
      0012C1 CFu00u1E         [ 2] 3359 	ldw	_timeRes+0, x
                                   3360 ;	clock.c: 580: }
      0012C4                       3361 00115$:
                                   3362 ;	clock.c: 583: if(timeRes>0){
      0012C4 CEu00u20         [ 2] 3363 	ldw	x, _timeRes+2
      0012C7 26 08            [ 1] 3364 	jrne	00217$
      0012C9 CEu00u1E         [ 2] 3365 	ldw	x, _timeRes+0
      0012CC 26 03            [ 1] 3366 	jrne	00217$
      0012CE CCr13rA3         [ 2] 3367 	jp	00123$
      0012D1                       3368 00217$:
                                   3369 ;	clock.c: 584: conSec(timeRes);
      0012D1 3Bu00u21         [ 1] 3370 	push	_timeRes+3
      0012D4 3Bu00u20         [ 1] 3371 	push	_timeRes+2
      0012D7 3Bu00u1F         [ 1] 3372 	push	_timeRes+1
      0012DA 3Bu00u1E         [ 1] 3373 	push	_timeRes+0
      0012DD CDr06r1B         [ 4] 3374 	call	_conSec
      0012E0 5B 04            [ 2] 3375 	addw	sp, #4
                                   3376 ;	clock.c: 585: TM1637_seg[0] = ASCI[con_hour/10];
      0012E2 AEr00r03         [ 2] 3377 	ldw	x, #_TM1637_seg+0
      0012E5 1F 24            [ 2] 3378 	ldw	(0x24, sp), x
      0012E7 AEr00r07         [ 2] 3379 	ldw	x, #_ASCI+0
      0012EA 1F 2E            [ 2] 3380 	ldw	(0x2e, sp), x
      0012EC 4B 0A            [ 1] 3381 	push	#0x0a
      0012EE 5F               [ 1] 3382 	clrw	x
      0012EF 89               [ 2] 3383 	pushw	x
      0012F0 4B 00            [ 1] 3384 	push	#0x00
      0012F2 3Bu00u18         [ 1] 3385 	push	_con_hour+3
      0012F5 3Bu00u17         [ 1] 3386 	push	_con_hour+2
      0012F8 3Bu00u16         [ 1] 3387 	push	_con_hour+1
      0012FB 3Bu00u15         [ 1] 3388 	push	_con_hour+0
      0012FE CDr00r00         [ 4] 3389 	call	__divulong
      001301 5B 08            [ 2] 3390 	addw	sp, #8
      001303 72 FB 2E         [ 2] 3391 	addw	x, (0x2e, sp)
      001306 F6               [ 1] 3392 	ld	a, (x)
      001307 1E 24            [ 2] 3393 	ldw	x, (0x24, sp)
      001309 F7               [ 1] 3394 	ld	(x), a
                                   3395 ;	clock.c: 586: TM1637_seg[1] = ASCI[con_hour%10];
      00130A 1E 24            [ 2] 3396 	ldw	x, (0x24, sp)
      00130C 5C               [ 2] 3397 	incw	x
      00130D 1F 11            [ 2] 3398 	ldw	(0x11, sp), x
      00130F 4B 0A            [ 1] 3399 	push	#0x0a
      001311 5F               [ 1] 3400 	clrw	x
      001312 89               [ 2] 3401 	pushw	x
      001313 4B 00            [ 1] 3402 	push	#0x00
      001315 3Bu00u18         [ 1] 3403 	push	_con_hour+3
      001318 3Bu00u17         [ 1] 3404 	push	_con_hour+2
      00131B 3Bu00u16         [ 1] 3405 	push	_con_hour+1
      00131E 3Bu00u15         [ 1] 3406 	push	_con_hour+0
      001321 CDr00r00         [ 4] 3407 	call	__modulong
      001324 5B 08            [ 2] 3408 	addw	sp, #8
      001326 72 FB 2E         [ 2] 3409 	addw	x, (0x2e, sp)
      001329 F6               [ 1] 3410 	ld	a, (x)
      00132A 1E 11            [ 2] 3411 	ldw	x, (0x11, sp)
      00132C F7               [ 1] 3412 	ld	(x), a
                                   3413 ;	clock.c: 587: TM1637_seg[2] = ASCI[con_min/10];
      00132D 1E 24            [ 2] 3414 	ldw	x, (0x24, sp)
      00132F 5C               [ 2] 3415 	incw	x
      001330 5C               [ 2] 3416 	incw	x
      001331 1F 3C            [ 2] 3417 	ldw	(0x3c, sp), x
      001333 4B 0A            [ 1] 3418 	push	#0x0a
      001335 5F               [ 1] 3419 	clrw	x
      001336 89               [ 2] 3420 	pushw	x
      001337 4B 00            [ 1] 3421 	push	#0x00
      001339 3Bu00u1C         [ 1] 3422 	push	_con_min+3
      00133C 3Bu00u1B         [ 1] 3423 	push	_con_min+2
      00133F 3Bu00u1A         [ 1] 3424 	push	_con_min+1
      001342 3Bu00u19         [ 1] 3425 	push	_con_min+0
      001345 CDr00r00         [ 4] 3426 	call	__divulong
      001348 5B 08            [ 2] 3427 	addw	sp, #8
      00134A 72 FB 2E         [ 2] 3428 	addw	x, (0x2e, sp)
      00134D F6               [ 1] 3429 	ld	a, (x)
      00134E 1E 3C            [ 2] 3430 	ldw	x, (0x3c, sp)
      001350 F7               [ 1] 3431 	ld	(x), a
                                   3432 ;	clock.c: 588: TM1637_seg[3] = ASCI[con_min%10];
      001351 1E 24            [ 2] 3433 	ldw	x, (0x24, sp)
      001353 1C 00 03         [ 2] 3434 	addw	x, #0x0003
      001356 1F 13            [ 2] 3435 	ldw	(0x13, sp), x
      001358 4B 0A            [ 1] 3436 	push	#0x0a
      00135A 5F               [ 1] 3437 	clrw	x
      00135B 89               [ 2] 3438 	pushw	x
      00135C 4B 00            [ 1] 3439 	push	#0x00
      00135E 3Bu00u1C         [ 1] 3440 	push	_con_min+3
      001361 3Bu00u1B         [ 1] 3441 	push	_con_min+2
      001364 3Bu00u1A         [ 1] 3442 	push	_con_min+1
      001367 3Bu00u19         [ 1] 3443 	push	_con_min+0
      00136A CDr00r00         [ 4] 3444 	call	__modulong
      00136D 5B 08            [ 2] 3445 	addw	sp, #8
      00136F 72 FB 2E         [ 2] 3446 	addw	x, (0x2e, sp)
      001372 F6               [ 1] 3447 	ld	a, (x)
      001373 1E 13            [ 2] 3448 	ldw	x, (0x13, sp)
      001375 F7               [ 1] 3449 	ld	(x), a
                                   3450 ;	clock.c: 589: if(EEPROM_DATA(UpLevel))if(con_hour<10)	TM1637_seg[0] =  0x00; //Отключение первого разряда если в нем 0
      001376 AE 40 09         [ 2] 3451 	ldw	x, #0x4009
      001379 F6               [ 1] 3452 	ld	a, (x)
      00137A 4D               [ 1] 3453 	tnz	a
      00137B 27 15            [ 1] 3454 	jreq	00119$
      00137D CEu00u17         [ 2] 3455 	ldw	x, _con_hour+2
      001380 A3 00 0A         [ 2] 3456 	cpw	x, #0x000a
      001383 C6u00u16         [ 1] 3457 	ld	a, _con_hour+1
      001386 A2 00            [ 1] 3458 	sbc	a, #0x00
      001388 C6u00u15         [ 1] 3459 	ld	a, _con_hour+0
      00138B A2 00            [ 1] 3460 	sbc	a, #0x00
      00138D 24 03            [ 1] 3461 	jrnc	00119$
      00138F 1E 24            [ 2] 3462 	ldw	x, (0x24, sp)
      001391 7F               [ 1] 3463 	clr	(x)
      001392                       3464 00119$:
                                   3465 ;	clock.c: 590: if(dot) TM1637_seg[1] = TM1637_seg[1] + 0x80; //Включение секундных точек
      001392 72 00u00u07 02   [ 2] 3466 	btjt	_dot+0, #0, 00220$
      001397 20 27            [ 2] 3467 	jra	00124$
      001399                       3468 00220$:
      001399 1E 11            [ 2] 3469 	ldw	x, (0x11, sp)
      00139B F6               [ 1] 3470 	ld	a, (x)
      00139C AB 80            [ 1] 3471 	add	a, #0x80
      00139E 1E 11            [ 2] 3472 	ldw	x, (0x11, sp)
      0013A0 F7               [ 1] 3473 	ld	(x), a
      0013A1 20 1D            [ 2] 3474 	jra	00124$
      0013A3                       3475 00123$:
                                   3476 ;	clock.c: 593: TM1637_seg[0] = 0x40;
      0013A3 AEr00r03         [ 2] 3477 	ldw	x, #_TM1637_seg+0
      0013A6 1F 07            [ 2] 3478 	ldw	(0x07, sp), x
      0013A8 1E 07            [ 2] 3479 	ldw	x, (0x07, sp)
      0013AA A6 40            [ 1] 3480 	ld	a, #0x40
      0013AC F7               [ 1] 3481 	ld	(x), a
                                   3482 ;	clock.c: 594: TM1637_seg[1] = 0x40;
      0013AD 1E 07            [ 2] 3483 	ldw	x, (0x07, sp)
      0013AF 5C               [ 2] 3484 	incw	x
      0013B0 A6 40            [ 1] 3485 	ld	a, #0x40
      0013B2 F7               [ 1] 3486 	ld	(x), a
                                   3487 ;	clock.c: 595: TM1637_seg[2] = 0x40;
      0013B3 1E 07            [ 2] 3488 	ldw	x, (0x07, sp)
      0013B5 5C               [ 2] 3489 	incw	x
      0013B6 5C               [ 2] 3490 	incw	x
      0013B7 A6 40            [ 1] 3491 	ld	a, #0x40
      0013B9 F7               [ 1] 3492 	ld	(x), a
                                   3493 ;	clock.c: 596: TM1637_seg[3] = 0x40;
      0013BA 1E 07            [ 2] 3494 	ldw	x, (0x07, sp)
      0013BC A6 40            [ 1] 3495 	ld	a, #0x40
      0013BE E7 03            [ 1] 3496 	ld	(0x0003, x), a
      0013C0                       3497 00124$:
                                   3498 ;	clock.c: 598: TM1637_send();
      0013C0 CDr01r39         [ 4] 3499 	call	_TM1637_send
                                   3500 ;	clock.c: 600: Soft_Timer = 0x00; //Сброс таймера
      0013C3 5F               [ 1] 3501 	clrw	x
      0013C4 CFu00u21         [ 2] 3502 	ldw	_Soft_Timer+0, x
      0013C7 CCr10rD3         [ 2] 3503 	jp	00128$
      0013CA 5B 42            [ 2] 3504 	addw	sp, #66
      0013CC 81               [ 4] 3505 	ret
                                   3506 	.area CODE
                                   3507 	.area INITIALIZER
      000000                       3508 __xinit__brigh:
      000000 07                    3509 	.db #0x07	; 7
      000001                       3510 __xinit__command1:
      000001 40                    3511 	.db #0x40	; 64
      000002                       3512 __xinit__command2:
      000002 C0                    3513 	.db #0xC0	; 192
      000003                       3514 __xinit__TM1637_seg:
      000003 FF                    3515 	.db #0xFF	; 255
      000004 FF                    3516 	.db #0xFF	; 255
      000005 FF                    3517 	.db #0xFF	; 255
      000006 FF                    3518 	.db #0xFF	; 255
      000007                       3519 __xinit__ASCI:
      000007 3F                    3520 	.db #0x3F	; 63
      000008 06                    3521 	.db #0x06	; 6
      000009 5B                    3522 	.db #0x5B	; 91
      00000A 4F                    3523 	.db #0x4F	; 79	'O'
      00000B 66                    3524 	.db #0x66	; 102	'f'
      00000C 6D                    3525 	.db #0x6D	; 109	'm'
      00000D 7D                    3526 	.db #0x7D	; 125
      00000E 07                    3527 	.db #0x07	; 7
      00000F 7F                    3528 	.db #0x7F	; 127
      000010 6F                    3529 	.db #0x6F	; 111	'o'
      000011                       3530 __xinit__con_day:
      000011 00 00 00 00           3531 	.byte #0x00,#0x00,#0x00,#0x00	; 0
      000015                       3532 __xinit__con_hour:
      000015 00 00 00 00           3533 	.byte #0x00,#0x00,#0x00,#0x00	; 0
      000019                       3534 __xinit__con_min:
      000019 00 00 00 00           3535 	.byte #0x00,#0x00,#0x00,#0x00	; 0
      00001D                       3536 __xinit__con_sec:
      00001D 00 00 00 00           3537 	.byte #0x00,#0x00,#0x00,#0x00	; 0
      000021                       3538 __xinit__Soft_Timer:
      000021 00 00                 3539 	.dw #0x0000
      000023                       3540 __xinit__Point_Meny:
      000023 00 00                 3541 	.dw #0x0000
      000025                       3542 __xinit__Buff_But:
      000025 FF                    3543 	.db #0xFF	; 255
      000026                       3544 __xinit__auto_exit:
      000026 00                    3545 	.db #0x00	; 0
      000027                       3546 __xinit__buff:
      000027 00                    3547 	.db #0x00	;  0
                                   3548 	.area CABS (ABS)
